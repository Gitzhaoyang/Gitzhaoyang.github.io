[{"categories":null,"content":"介绍 在 非阻塞 I/O 超简明介绍 中， 我们已经讨论过现代 Web 服务器可以处理大量并发请求，这得益于现代操作系统内核内置的事件通知机制。 受 Linux epoll [ 文档 ] 启发， FreeBSD 发明了 kqueue [ 论文 , 文档 ]\n这篇文章我们将仔细研究下 kqueue，我们会用 Go 实现一个基于 kqueue event loop 的 TCP server， 你可以在 Github 上找到 源代码 。 要运行代码必须使用和 FreeBSD 兼容的操作系统，比如 macOS。\n注意 kqueue 不仅能处理 socket event，而且还能处理文件描述符 event、信号、异步 I/O event、子进程状态改变 event、 定时器以及用户自定义 event。它确实通用和强大。\n我们这篇文章主要分为一下几部分讲解。 首先，我们会在先从理论出发设计我们的 TCP Server。 然后，我们会去实现它的必要的模块。 最后我们会对整个过程进行总结以及思考。\n设计 我们 TCP Server 大概有以下几部分： 一个监听 TCP 的 socket、 接收客户端连接的 socket、 一个内核事件队列（kqueue）， 还有一个事件循环机制来轮询这个队列。 下面这个图描述了接收连接的场景。\n当客户端想要连接服务端，一个连接请求将会被放到 TCP 连接队列中， 而内核会将一个新的事件放到 kqueue 中。 这个事件将会在事件循环时被处理，事件循环会接受请求，并创建一个新的客户端连接。 下面这个图描述了新创建的 socket 如何从客户端读取请求。\n客户端写数据到新创建的 socket，内核会将一个新 event 放到 kqueue 中，表示在这个 socket 中有等待读取的数据。 事件循环将轮询到这个事件，并从 socket 读取数据。 注意只有一个 socket 监听连接，而我们将为每一个客户端连接创建新的 socket。\n下文要讨论实现细节，可以大概按照下面的步骤实现我们的设计。\n1 创建，绑定以及监听新的 socket 2 创建 kqueue 3 订阅 socket event 4 循环队列获取 event 并处理它们\n实现 为了避免单个文件有大量系统调用，我们拆分成几个不同模块：\n 一个 socket 模块来处理所有管理 socket 的相关功能， 一个 kqueue 模块来处理事件循环， 最后 main 模块用来整合所有模块并启动我们的 TCP server。  我们下面从 socket 模块开始。\n定义 Socket 首先，让我们创建一个 socket 结构体。类 Unix 操作系统，比如 FreeBSD，会把 socket 作为文件。 为了用 Go 实现 socket，我们需要了解 文件描述符。 所以我们可以创建一个类似下面带有文件描述符的结构体。\n1 2 3 4 5  type Socket struct { FileDescriptor int }   我们期望我们的 socket 可以应对不同的场景，比如：读、写 socket 数据，以及关闭 socket。 在 Go 中，要支持这些操作，需要实现通用的 interface，比如 io.Reader，io.Writer，还有 io.Closer\n首先，实现 io.Reader 这个接口，他会调用 read() 系统函数。 这个函数会返回读到字节的数量，以及进行读操作时可能发生的错误。\n1 2 3 4 5 6 7 8 9 10 11 12 13  func (socket Socket) Read(bytes []byte) (int, error) { if len(bytes) == 0 { return 0, nil } numBytesRead, err := syscall.Read(socket.FileDescriptor, bytes) if err != nil { numBytesRead = 0 } return numBytesRead, err }   类似的，我们通过调用 write() 来实现 io.Writer 接口。\n1 2 3 4 5 6 7 8 9  func (socket Socket) Write(bytes []byte) (int, error) { numBytesWritten, err := syscall.Write(socket.FileDescriptor, bytes) if err != nil { numBytesWritten = 0 } return numBytesWritten, err }   最后关闭 socket 可以调用 close() ，并传入 socket 对应的文件描述符。\n1 2 3  func (socket *Socket) Close() error { return syscall.Close(socket.FileDescriptor) }   为了稍后能打印一些有用的错误和日志，我们也需要实现 fmt.Stringer 接口。 我们通过不同的文件描述符来区分不同的 socket。\n1 2 3  func (socket *Socket) String() string { return strconv.Itoa(socket.FileDescriptor) }   监听一个 Socket 定义好 Socket 之后，我们需要初始化它，并让它一个监听特定 IP 和 端口的。 监听一个 socket 也可以通过一些系统函数来实现。 现在先整体看一下我们实现的 Listen() 方法，然后再一步步进行分析。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  func Listen(ip string, port int) (*Socket, error) { socket := \u0026Socket{} socketFileDescriptor, err := syscall.Socket(syscall.AF_INET, syscall.SOCK_STREAM, 0) if err != nil { return nil, fmt.Errorf(\"failed to create socket (%v)\", err) } socket.FileDescriptor = socketFileDescriptor socketAddress := \u0026syscall.SockaddrInet4{Port: port} copy(socketAddress.Addr[:], net.ParseIP(ip)) if err = syscall.Bind(socket.FileDescriptor, socketAddress); err != nil { return nil, fmt.Errorf(\"failed to bind socket (%v)\", err) } if err = syscall.Listen(socket.FileDescriptor, syscall.SOMAXCONN); err != nil { return nil, fmt.Errorf(\"failed to listen on socket (%v)\", err) } return socket, nil }   首先调用了 socket() 函数， 这将会创建通信的接入点，并返回描述符编号。 它需要 3 个参数：\n 地址类型：我们用的是 AF_INET (IPv4) socket 类型：我们用 SOCKET_STREAM，代表基于字节流连续、可靠的双向连接。 协议类型：0 在 SOCKET_STREAM 类型下代表的是 TCP。  然后，我们调用了 bind() 方法来指定新创建 socket 的协议地址。 bind() 方法的第一个参数是文件描述符，第二个参数是包含地址信息的结构体指针。 我们在这里使用了 Go 预定义的 SockaddrInet4 结构体，并指定要绑定的 IP 地址和端口。\n最后，我们调用了 listen() 方法，这样我们就能等待接收连接了。 它的第二个参数是连接请求队列的最大长度。 我们使用了内核参数 SOMAXCONN ，在我的 Mac 上默认是 128。 你可以通过执行 sysctl kern.ipc.somaxconn 来获取这个值。\n定义事件循环 同样的，我们将定义一个结构体来表示 kqueue 的事件循环。 我们必须要保存 kqueue 的文件描述符以及 socket 的文件描述符, 我们当然也能将我们前面定义的 socket 对象作为指针来替代 SocketFileDescriptor。\n1 2 3 4 5 6  type EventLoop struct { KqueueFileDescriptor int SocketFileDescriptor int }   接下来，我们需要一个函数根据我们提供的 socket 创建一个事件循环。 和之前一样，我们需要用一系列系统函数去创建 Kqueue。 我们还是先看下整个函数，然后再一步步拆解来看。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  func NewEventLoop(s *socket.Socket) (*EventLoop, error) { kQueue, err := syscall.Kqueue() if err != nil { return nil, fmt.Errorf(\"failed to create kqueue file descriptor (%v)\", err) } changeEvent := syscall.Kevent_t{ Ident: uint64(s.FileDescriptor), Filter: syscall.EVFILT_READ, Flags: syscall.EV_ADD | syscall.EV_ENABLE, Fflags: 0, Data: 0, Udata: nil, } changeEventRegistered, err := syscall.Kevent( kQueue, []syscall.Kevent_t{changeEvent}, nil, nil ) if err != nil || changeEventRegistered == -1 { return nil, fmt.Errorf(\"failed to register change event (%v)\", err) } return \u0026EventLoop{ KqueueFileDescriptor: kQueue, SocketFileDescriptor: s.FileDescriptor }, nil }   第一个系统函数 kqueue() 创建了一个新的内核事件队列，并且返回了它的文件描述符。 我们等会调用 kevent() 的时候会用到这个队列。 kevent() 有两个功能，订阅新事件和轮询队列。\n我们的例子是要订阅传入连接的事件， 可以通过传递 kevent 结构体（在 Go 中，用 Kevent_t 表示）给 kevent() 这个系统函数来实现订阅。 Kevent_t 需要包含以下信息：\n Ident 的文件描述符：值是我们 socket 的文件描述符 处理事件的 Filter：设置为 EVFILT_READ，当和监听 socket 一起用时，它代表我们只关心传入连接的事件。 代表对这个事件要执行操作的 Flag：在我们例子中，我们想要添加（EV_ADD）事件到 kqueue，比如说订阅事件，同时要启用（EV_ENABLE）它。Flag 可以使用 或 这个位操作进行结合。  其他的几个参数我们就不需要了，创建好这个事件之后，要把它用一个数组包裹，并传递给 kevent() 这个系统函数。 最后，我们返回这个等待被轮询的事件循环。接下来让我们实现轮询的函数。\n事件循环轮询 事件循环是一个简单的 for 循环，可以轮询新的内核事件并进行处理。 之前使用系统函数 kevent() 时，订阅轮询就已经完成了，但是现在我们又传递一个空的事件数组给它， 目的是当有新的事件时，新的事件会填充到这个数组。\n然后我们就可以一个个循环这些事件并处理它们了。 新的客户端连接会被转换成客户端 socket，所以我们可以从客户端读取或写入数据。 现在让我们看下代码如何循环不同的事件类型。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56  func (eventLoop *EventLoop) Handle(handler Handler) { for { newEvents := make([]syscall.Kevent_t, 10) numNewEvents, err := syscall.Kevent( eventLoop.KqueueFileDescriptor, nil, newEvents, nil ) if err != nil { continue } for i := 0; i \u003c numNewEvents; i++ { currentEvent := newEvents[i] eventFileDescriptor := int(currentEvent.Ident) if currentEvent.Flags\u0026syscall.EV_EOF != 0 { // client closing connection  syscall.Close(eventFileDescriptor) } else if eventFileDescriptor == eventLoop.SocketFileDescriptor { // new incoming connection  socketConnection, _, err := syscall.Accept(eventFileDescriptor) if err != nil { continue } socketEvent := syscall.Kevent_t{ Ident: uint64(socketConnection), Filter: syscall.EVFILT_READ, Flags: syscall.EV_ADD, Fflags: 0, Data: 0, Udata: nil, } socketEventRegistered, err := syscall.Kevent( eventLoop.KqueueFileDescriptor, []syscall.Kevent_t{socketEvent}, nil, nil ) if err != nil || socketEventRegistered == -1 { continue } } else if currentEvent.Filter\u0026syscall.EVFILT_READ != 0 { // data available -\u003e forward to handler  handler(\u0026socket.Socket{ FileDescriptor: int(eventFileDescriptor) }) } // ignore all other events  } } }   第一种情况，我们要处理 EV_EOF 事件，代表客户端想要关闭它的连接的事件。这种情况我们简单的关闭了对应 socket 的文件描述符。\n第二种情况代表我们的监听 socket 有连接请求。 我们可以使用系统函数 accept() 从 TCP 连接请求队列中获取连接请求， 它会为监听 socket 创建一个新的客户端 socket 和新的文件描述符。 我们为这个新创建的 socket 订阅一个新的 EVFILT_READ 事件。 在新创建的客户端 socket 中，无论什么时候有可以读取的数据，就会有 EVFILT_READ 事件发生。\n第三种情况就是处理刚提到的 EVFILT_READ 事件，这些事件有客户端 socket 的文件描述符， 我们将其封装在 Socket 对象中并传递给要处理它的方法。\n要注意我们省略一些错误然后使用了简单的 continue 继续执行循环。现在事件循环函数也写好了，让我们将所有的逻辑封装在 main 函数中并执行。\nmain 函数 因为之前已经定义好了 socket 和 kqueue 模块，我们现在可以非常容易地实现服务器。 我们首先创建一个监听特定 IP 地址和端口的 socket，然后基于它创建一个新的事件循环， 最后我们定义处理输出的函数，来开启我们的事件循环。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  func main() { s, err := socket.Listen(\"127.0.0.1\", 8080) if err != nil { log.Println(\"Failed to create Socket:\", err) os.Exit(1) } eventLoop, err := kqueue.NewEventLoop(s) if err != nil { log.Println(\"Failed to create event loop:\", err) os.Exit(1) } log.Println(\"Server started. Waiting for incoming connections. ^C to exit.\") eventLoop.Handle(func(s *socket.Socket) { reader := bufio.NewReader(s) for { line, err := reader.ReadString('\\n') if err != nil || strings.TrimSpace(line) == \"\" { break } s.Write([]byte(line)) } s.Close() }) }   处理函数会根据换行符逐行读取数据内容，直到它读取到空行，然后会关闭连接。 我们可以通过 curl 来测试，curl 将会发送一个 GET 请求，并输出响应的内容，响应内容其实就是它发送的 GET 请求体的内容。\n思考 我们成功用 kqueue 实现了一个简单的 TCP Server，当然，这个代码想用于生产环境还需要做很多工作。 我们使用单进程和阻塞 socket 运行，另外，也没有去处理错误。 其实大多数情况下，使用已经存在的库而不是自己调用操作系统内核函数会更好。\n没想到用内核操作事件这么难，API 非常复杂，而且必须要读好多文档去找需要怎么做。 然而，这是一个惊人的学习体验。\n via: https://dev.to/frosnerd/writing-a-simple-tcp-server-using-kqueue-cah\n作者：Frank Rosner 译者：h1z3y3 校对：polarisxu\n本文由 GCTT 原创编译，Go 中文网 荣誉推出\n","description":"","tags":["Golang","GCTT"],"title":"用 kqueue 实现一个简单的 TCP Server","uri":"/posts/writing-a-tcp-server-using-kqueue/"},{"categories":null,"content":"英文原文链接：https://www.zdnet.com/article/http-over-quic-to-be-renamed-http3/\n据 IETF 官方人员透露，HTTP-over-QUIC 实验方案将会被命名为 HTTP/3，并将成为 HTTP 协议的第三个官方版本。 在谷歌将 SPDY 技术发展成为 HTTP/2 协议之后，这是谷歌第二次将实验技术发展成为 HTTP 的官方协议版本。 HTTP-over-QUIC 协议是 HTTP 协议的升级，谷歌使用 QUIC 取代 TCP (Transmission Control Protocal) 作为 HTTP 的基础技术。 QUIC 全称 Quick UDP Internet Connections，是谷歌将 TCP 协议重写为一种结合了HTTP/2、TCP、UDP 和 TLS 的改进技术。\n谷歌希望 QUIC 能逐渐取代 TCP 和 UDP 成为在因特网传输二进制数据协议的新选择，而使用它的更好的理由，是 QUIC 的加密方案实现已经被测试证明更快而且更安全 (目前 HTTP-over-QUIC 协议草案使用的是 TLS1.3 协议)。\nQUIC 被提议作为2015年 IETF 的标准草案，而 HTTP-over-QUIC 这个基于 QUIC 而不是 TCP 重写 HTTP 的协议则在2016年7月被提议。 在那之后，HTTP-over-QUIC 在 Chrome 29、Opera 16 被支持，当然还有一些低性能的浏览器。最初，只有谷歌的服务器支持 HTTP-over-QUIC，今年，Facebook也开始采用这项技术。 在2018年10月份的邮件讨论里，IETF HTTP 和 QUIC 工作组的主席 Mark Nottingham 提出了将 HTTP-over-QUIC 重命名为 HTTP/3 的官方申请，并希望将 QUIC 工作组的开发工作转递给 HTTP 工作组。 经过几天的讨论，Nottingham 的提议被 IETF 的成员接受并给出了官方认可，将 HTTP-over-QUIC 作为 HTTP 协议的下一个版本 —— HTTP/3，用于完善优化当今的网络。 根据 W3Techs 的统计，截止2018年11月，全球访问量最高的1千万个网站中，已经有31.2%的网站支持了 HTTP/2，只有1.2%的网站支持了 QUIC。\n以下是自己的一点思考：\n可以看到，HTTP/3 协议带来的最大改变是协议底层将采用 UDP 协议，而不再是 TCP 协议，那这样的好处可以说是更低时延和更好的拥塞控制，还有更高效率的多路复用，可以说谷歌真的很厉害了，要知道 HTTP/2 也是谷歌的 SPDY 标准化之后的协议。而且这次 QUIC 发音同 quick ，上次 SPDY 发音同 speedy，是巧合还是有意为之呢。：）\n真是强者制定规则：\n They are in control of future web protocol development.\n","description":"","tags":["HTTP"],"title":"译：HTTP/3 来了","uri":"/posts/http3/"},{"categories":null,"content":"工厂方法模式是简单工厂的升级。他创建一个用于实例化类的接口，并由工厂的子类决定实例化哪个类。工厂方法模式使得一个类的实例化延迟到子类。\n下面仍然以“两个数字的运算”作为例子\noperations.go // 运算类\npackage factory_method // 运算 type Operation interface { SetA(float64) SetB(float64) GetResult() (float64, error) } // 运算基类，实现公共的方法 type OperationBase struct { a float64 b float64 } func (oper *OperationBase) SetA(a float64) { oper.a = a } func (oper *OperationBase) SetB(b float64) { oper.b = b } // 加法运算 type AddOperation struct { *OperationBase } func (oper *AddOperation) GetResult() (float64, error) { return oper.a + oper.b, nil } // 减法运算 type SubOperation struct { *OperationBase } func (oper *SubOperation) GetResult() (float64, error) { return oper.a - oper.b, nil } // 乘法元算 type MulOperation struct { *OperationBase } func (oper *MulOperation) GetResult() (float64, error) { return oper.a * oper.b, nil } factory_method.go // 工厂类\npackage factory_method // 工厂类 type OperationFactory interface { CreateOperation() Operation } // 加法工厂 type AddFactory struct { } func (f *AddFactory) CreateOperation() Operation { return \u0026AddOperation{ OperationBase: \u0026OperationBase{}, } } // 减法工厂 type SubFactory struct { } func (f *SubFactory) CreateOperation() Operation { return \u0026SubOperation{ OperationBase: \u0026OperationBase{}, } } // 乘法工厂 type MulFactory struct { } func (f *MulFactory) CreateOperation() Operation { return \u0026MulOperation{ OperationBase: \u0026OperationBase{}, } } 源码以及测试源码下载地址：https://github.com/h1z3y3/big-talk-go-design-patterns/tree/master/04_factory_method\n","description":"","tags":["设计模式","Golang"],"title":"设计模式：工厂方法模式","uri":"/posts/design-pattern-factory-method/"},{"categories":null,"content":"代理模式即在真实类的基础上封装一层代理类，由代理类完成对真实类的调用。 以便可以在代理类中做一些额外的工作，如进行访问权限校验、保存Cache缓存等操作。\n下面以\"读取图片资源\"为例说明代理模式：\npackage proxy // 接口，代理类和真实类都要实现 type Image interface { Get() string } // 真实的图片类 type RealImage struct {} func (r *RealImage) Get() string { return \"real_image_url\" } // 代理类 type ImageProxy struct { realImage RealImage } // 由代理类进行原类的调用，从而能在原类基础上做一些操作 func (r *ImageProxy) Get() string { var res string // pre: 权限检查、查看是否有cache等 res += \"pre:\" res += r.realImage.Get() // after: 保存cache、格式化结果等 res += \":after\" return res } 源码以及测试源码下载地址：https://github.com/h1z3y3/big-talk-go-design-patterns/tree/master/03_proxy\n","description":"","tags":["设计模式","Golang"],"title":"设计模式：代理模式","uri":"/posts/design-pattern-proxy/"},{"categories":null,"content":" 平均负载是单位时间内“正在使用CPU”、“等待CPU”、“等待IO”的进程数量 平均负载和CPU使用率不一样，但是CPU密集型任务可能导致平均负载升高 由1，2可知，平均负载升高，不一定是由于CPU使用率高导致，也可能是IO繁忙 除了top命令，还有mpstat、pidstat等命令 watch命令，可以检测一个命令的执行结果，而不必一次次手动输入运行 uptime命令  ","description":"","tags":["Linux"],"title":"Linux:平均负载","uri":"/posts/linux-avarage-load/"},{"categories":null,"content":"装饰器模式主要解决要动态的给一个类添加一些新功能，而又不想让这个类变得庞大。 这种模式需要创建一个装饰类来包装扩展原有的类，并且在保证原有的类保持结构一致的前提下，提供额外的功能。\n下面是给一个人装饰衣服的实例：\npackage decorator import \"fmt\" type Person interface { Show() } // 具体实现 type ConcreteComponent struct { } func (c *ConcreteComponent) Show() { fmt.Print(\"A Person wears sunglasses; \") } // 男人 type Man struct{} func (m *Man) Show() { fmt.Print(\"A man wear a hat!\") } // 女人 type Woman struct{} func (w *Woman) Show() { fmt.Print(\"A woman wear a skirt!\") } // TShirt type TShirtDecorator struct { Person Color string } func (t *TShirtDecorator) Show() { t.Person.Show() // 调用父类的 Show() 方法 // \"装饰\": 增加自己特有的属性 fmt.Print(fmt.Sprintf(\"Color: %s, TShirt; \", t.Color)) } func WearTShirt(p Person, c string) Person { return \u0026TShirtDecorator{ Person: p, Color: c, } } // Pants type PantsDecorator struct { Person Length int64 } func (p *PantsDecorator) Show() { p.Person.Show() fmt.Print(fmt.Sprintf(\"Lenght: %dcm, Pants.; \", p.Length)) } func WearPants(p Person, l int64) Person { return \u0026PantsDecorator{ Person: p, Length: l, } } // Shoes type ShoesDecorator struct { Person Size int64 } func (s *ShoesDecorator) Show() { s.Person.Show() fmt.Print(fmt.Sprintf(\"Size: %d, Shoes; \", s.Size)) } func WearShoes(p Person, s int64) Person { return \u0026ShoesDecorator{ Person: p, Size: s, } } // Examples func ExampleConcrete_Wear() { var p Person = \u0026ConcreteComponent{} p = WearTShirt(p, \"Blue\") p = WearPants(p, 100) p = WearShoes(p, 42) p.Show() // Output: A Person wears sunglasses; Color: Blue, TShirt; Lenght: 100cm, Pants.; Size: 42, Shoes; } func ExampleMan_Show() { var xiaoming Person = \u0026Man{} xiaoming = WearShoes(xiaoming, 43) xiaoming = WearTShirt(xiaoming, \"White\") xiaoming.Show() // Output:A man wear a hat!Size: 43, Shoes; Color: White, TShirt; } func ExampleWoman_Show() { var xiaohong Person = \u0026Woman{} xiaohong = WearTShirt(xiaohong, \"Red\") xiaohong = WearShoes(xiaohong, 38) xiaohong.Show() // Output: A woman wear a skirt!Color: Red, TShirt; Size: 38, Shoes; } 源码以及测试源码下载地址：https://github.com/h1z3y3/big-talk-go-design-patterns/tree/master/02_decorator\n","description":"","tags":["设计模式","Golang"],"title":"设计模式：装饰器模式","uri":"/posts/design-pattern-decorator/"},{"categories":null,"content":"在策略模式中，我们需要创建一系列策略对象和一个能随策略对象改变而改变的Context对象，策略对象改变Context的执行方法。\n仍以两个数字的加减乘除操作作为示例\npackage strategy import \"fmt\" // Context 类 type Context struct { strategy Strategy } func NewContext(strategy Strategy) *Context { return \u0026Context{ strategy: strategy, } } func (c *Context) GetResult(a float64, b float64) (float64, error) { return c.strategy.GetResult(a, b) } // 策略接口 type Strategy interface { GetResult(a float64, b float64) (float64, error) } // 以下类实现策略接口 // 加法 type Add struct{} func (o *Add) GetResult(a float64, b float64) (float64, error) { return a + b, nil } // 减法 type Sub struct{} func (o *Sub) GetResult(a float64, b float64) (float64, error) { return a - b, nil } // 乘法 type Mul struct{} func (o *Mul) GetResult(a float64, b float64) (float64, error) { return a * b, nil } // 除法 type Div struct{} func (o *Div) GetResult(a float64, b float64) (float64, error) { if b == 0 { return 0, fmt.Errorf(\"除数不能为0\") } return a / b, nil } 源码以及测试源码下载地址：https://github.com/h1z3y3/big-talk-go-design-patterns/tree/master/01_strategy\n","description":"","tags":["设计模式","Golang"],"title":"设计模式：策略模式","uri":"/posts/design-pattern-strategy/"},{"categories":null,"content":"这个系列是《大话设计模式》的读后感，将书中的设计模式用golang实现。\n第一个设计模式是简单工厂模式，主要用到的知识点是类的多态。 多态表示不同的类可以执行相同的方法，但要通过它们自己的实现代码来执行。 而在golang中没有类的概念，我们可以借助接口(interface)类型实现类的多态。\n如果一个类型实现了接口的所有方法，那么就可以说这个类型实现了这个接口。\n我们要实现两个数字的加减乘除操作作为示例\npackage simplefactory import \"fmt\" // 1. 定义一个接口类型，子类必须实现GoResult方法来实现该接口 type Operation interface { GetResult(a float64, b float64) (float64, error) } // 2. 初始化工厂类方法，传入操作符，返回对应的类 func NewOperation(oper string) Operation { switch oper { case \"+\": return \u0026operationAdd{} case \"-\": return \u0026operationSub{} case \"*\": return \u0026operationMul{} case \"/\": return \u0026operationDiv{} default: return nil } } // 加法 type operationAdd struct{} func (o *operationAdd) GetResult(a float64, b float64) (float64, error) { return a + b, nil } // 减法 type operationSub struct{} func (o *operationSub) GetResult(a float64, b float64) (float64, error) { return a - b, nil } // 乘法 type operationMul struct{} func (o *operationMul) GetResult(a float64, b float64) (float64, error) { return a * b, nil } // 除法 type operationDiv struct{} func (o *operationDiv) GetResult(a float64, b float64) (float64, error) { if b == 0 { return 0, fmt.Errorf(\"除数不能为0\") } return a / b, nil } 源码以及测试源码下载地址：https://github.com/h1z3y3/big-talk-go-design-patterns/tree/master/00_simple_factory\n","description":"","tags":["设计模式","Golang"],"title":"设计模式：简单工厂模式","uri":"/posts/design-pattern-simple-factory/"},{"categories":null,"content":" 计算密集型任务\n 计算密集型任务主要消耗CPU资源，需要进行大量的计算，如计算圆周率或对视频进行高清的解码等，全靠CPU的运算能力。这种任务虽然可以利用多任务去完成，但是任务越多，花在任务切换上的时间就会越多，那么CPU的执行效率就会越低，所以，要高效的利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数，尽量减少CPU在任务间的切换时间。\n IO密集型任务\n 一般涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点就是CPU消耗很少，任务的大部分时间都花在等待IO操作的完成。由于IO的速度远远低于CPU和内存的速度，所以IO密集型任务的数量越多，CPU的效率就会越高，但是也会有一定的限度。常见的大部分任务都是IO密集型任务，比如Web应用。\nIO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少，因此，用运行速度极快的C语言替换Python这样运行速度极低的脚本语言，也完全无法提升运行效率。对于IO密集型任务，最合适的语言就是开发效率最高，代码量最少的语言，脚本语言是首选，C语言最差。\n 总结\n 计算密集型程序适合C语言多线程\nIO密集型程序适合脚本语言开发的多线程\n","description":"","tags":["基础"],"title":"计算密集型 vs. IO密集型","uri":"/posts/cpu-io/"},{"categories":null,"content":"最近在做毕业设计，使用到了CkEditor和CkFinder来做富文本编辑框以及文件管理。 因为CkFinder只能下载使用Demo版本，会有一些版权信息。 我不是用做商业目的，仅仅为了学习，所以想把版权信息去掉。 看了几篇博客，都是教你把alert框加上display:none，我考虑到这样并不好，因为如果有其他正常的信息也不能显示了，所以花了些时间改了下ckfinder.js，既去掉了版权信息，又不会影响其他信息的提示。\n下文提供了两种方法，建议使用第二种。\n如果你是用于商业目的，请到官网购买使用的License使用。\nCKFinder版本: Version: 2.6.2.1 • Released 11 Oct 2016\n不想自己操作这么麻烦的，去CSDN下载我上传好的，2积分 哈哈哈\n链接：http://download.csdn.net/detail/qq1255685485/9845062\n第一种 第一种麻烦而且需要逻辑改动较大。\n左下角信息 在ckfinder.js中搜索:\nt=\"\\x54\\150\\151\\163\\040\\x69\\163\\x20\\164\\x68\\145\\040\\x44\\105\\x4d\\x4f\\040\\166\\x65\\x72\\x73\\x69\\157\\156\\x20\\157\\146\\040\\103\\113\\x46\\151\\x6e\\144\\145\\x72\\056\\040\\120\\154\\x65\\141\\163\\145\\040\\166\\x69\\x73\\x69\\x74\\x20\\164\\150\\145\\040\\x3c\\x61\\x20\\150\\162\\x65\\x66\\x3d\\x27\\150\\164\\x74\\x70\\x3a\\x2f\\x2f\\x63\\x6b\\163\\157\\x75\\x72\\x63\\x65\\056\\143\\x6f\\x6d\\057\\143\\153\\146\\151\\x6e\\144\\x65\\162\\x27\\x20\\164\\141\\162\\x67\\x65\\x74\\x3d\\047\\x5f\\x62\\154\\141\\x6e\\x6b\\x27\\x3e\\x43\\x4b\\106\\151\\156\\144\\x65\\x72\\040\\x77\\145\\x62\\040\\163\\151\\x74\\x65\\x3c\\x2f\\x61\\x3e\\x20\\164\\157\\040\\x6f\\x62\\x74\\141\\x69\\x6e\\x20\\141\\040\\166\\x61\\154\\151\\144\\040\\x6c\\151\\x63\\x65\\156\\163\\x65\\x2e\"  位置在文件比较靠后的位置，替换为:\nt=\"\"  这一句的解码后为:\nThis is the DEMO version of CKFinder.Please visit the \u003ca href='http://cksource.com/ckfinder' target='_blank'\u003eCKFinder web site\u003c/a\u003e to obtain a valid license.  可以在 http://ddecode.com/hexdecoder 解码\n顶端信息 在ckfinder.js中搜索:\nP=\"\\x50\\x6c\\x65\\141\\x73\\x65\\040\\166\\151\\x73\\x69\\x74\\x20\\164\\x68\\x65\\040\\074\\141\\040\\x68\\162\\x65\\146\\075\\x27\\x68\\164\\x74\\160\\072\\057\\057\\x63\\x6b\\x73\\x6f\\x75\\x72\\x63\\x65\\056\\x63\\157\\155\\057\\143\\x6b\\x66\\151\\x6e\\x64\\x65\\x72\\x27\\x20\\x74\\141\\162\\147\\145\\x74\\x3d\\x27\\x5f\\x62\\154\\141\\x6e\\153\\x27\\x3e\\x43\\x4b\\106\\x69\\x6e\\x64\\x65\\162\\x20\\x77\\x65\\142\\x20\\x73\\x69\\x74\\145\\x3c\\x2f\\x61\\x3e\\040\\x74\\x6f\\x20\\157\\142\\x74\\x61\\151\\156\\x20\\141\\040\\166\\141\\154\\151\\x64\\040\\154\\151\\143\\145\\x6e\\163\\145\\x2e\",Q=\"\\x54\\150\\x69\\163\\x20\\151\\x73\\040\\x74\\x68\\x65\\040\\x44\\x45\\x4d\\117\\040\\x76\\x65\\x72\\163\\x69\\157\\156\\x20\\157\\x66\\040\\x43\\x4b\\106\\x69\\156\\144\\145\\x72\\x2e\\x20\"+P,R=\"\\x50\\162\\157\\144\\x75\\x63\\164\\040\\154\\151\\143\\x65\\156\\163\\145\\x20\\150\\141\\x73\\x20\\x65\\x78\\160\\x69\\162\\145\\144\\x2e\\040\"+P;  这里定义了三个变量P, Q, R, 分别代表的意思如下:\nP=\"Please visit the \u003ca href='http://cksource.com/ckfinder' target='_blank'\u003eCKFinder web site\u003c/a\u003e to obtain a valid license.\"; Q=\"This is the DEMO version of CKFinder.\" + P; R=\"Product license has expired.\" + P;  将搜索到的内容替换为\nP=\"\"; Q=\"\"; R=\"\";  替换完成后发现文件库为空白，更具体可以说，当将Q设置为空白字符串之后才会显示空白，而替换P和R都不会出现这种情况，因为代码后面对Q的值做了判断.\n所以我们继续向下看，继续搜索：\nif(!Q)  可以看到这个判断if(!Q) return;,删除这一个判断体.\n还没有结束，继续搜索:\nQ.charAt  可以看到另外一个判断if(pw||Q.charAt(2\u003c\u003c2)!='t')return;，为了保证正常使用，将这个判断体替换为:\nif(pw) return;  另外多说一句，Q变量删除到Q=\"\\x54\\150\\x69\\163\\x20\\151\\x73\\040\\x74\"的时候还能正常使用，也就是Q=\"This is t\"，可以做些尝试。\n当以上工作全部完成之后，刷新页面即可以看到版权信息全部去掉了，而且并没有影响到其他信息的提醒。\n哈哈哈😂。看到这的都是真爱。 那么给你们说一个更简单的方法，只需三步，更完美的解决问题。\n第二种 简单，只需三步\n左下角信息 搜索: this.dV().getChild(0).appendHtml，很显然是为左下角添加信息，看这一句上面有个if判断:\n if (this.app.gd == 'bootstrap') { var H = \"\\x3c\\x64\\151\\x76\\x20\\143\\x6c\\x61\\x73\\x73\\x3d\\x27\\166\\x69\\145\\167\\x20\\164\\157\\157\\154\\137\\160\\141\\x6e\\145\\x6c\\047\\040\\x73\\x74\\x79\\154\\145\\075\\047\\x64\\151\\x73\\x70\\154\\141\\x79\\x3a\\x62\\x6c\\157\\143\\153\\x20\\x21\\x69\\x6d\\160\\157\\x72\\164\\x61\\x6e\\164\\x3b\\160\\x6f\\163\\x69\\x74\\151\\x6f\\x6e\\072\\x73\\x74\\x61\\164\\151\\143\\040\\x21\\x69\\x6d\\160\\157\\x72\\164\\x61\\x6e\\x74\\x3b\\x63\\x6f\\x6c\\157\\x72\\x3a\\043\\x33\\x31\\x37\\x30\\x38\\x66\\x20\\041\\151\\155\\x70\\157\\x72\\x74\\x61\\156\\x74\\073\\x62\\x61\\x63\\x6b\\147\\162\\157\\165\\x6e\\144\\055\\143\\157\\x6c\\x6f\\x72\\x3a\\x23\\144\\x39\\145\\144\\146\\x37\\x20\\x21\\x69\\x6d\\x70\\157\\x72\\x74\\141\\156\\x74\\073\\146\\x6f\\156\\164\\x2d\\x73\\151\\172\\x65\\x3a\\x20\\061\\063\\x70\\170\\073\\040\\x70\\141\\x64\\144\\x69\\156\\147\\072\\040\\x35\\x70\\170\\073\\x20\\155\\141\\162\\147\\x69\\x6e\\072\\065\\160\\170\\x3b\\x62\\157\\162\\144\\x65\\162\\055\\x72\\141\\144\\x69\\x75\\x73\\x3a\\x34\\160\\x78\\x3b\\047\\x3e\"; v = H + t + s; w = H + u + s; }  进行解码和字符串组合，可以看到变量v就是版权信息, w是已经购买的信息。在搜索到的this.dV().getChild(0).appendHtml括号里面，改为:\nthis.dV().getChild(0).appendHtml(C||D||A!=4?\"\":\"\");  简言之就是不管买没买，都不显示这个提示，设置为空字符串就好了。\n顶端信息 顶端的去处版权信息的方法和左下角类似。\n搜索: aT.mj=Q 替换为 aT.mj=Q.toLowerCase().indexOf(\"demo\") ? \"\" : Q; 搜索: aT.mj=R 替换为 aT.mj=R.toLowerCase().indexOf(\"demo\") ? \"\" : R;\n大功告成， 更完美的解决了问题～ 😎\n2017-5-17 更新：启用剪切功能 今天发现虽然版权信息没有了，但是“临时文件夹”功能“从临时文件夹剪切至此”在Demo版本中不能使用，提示:\nThis function is disabled in the demo version of CKFinder. Please visit the CKFinder web site to obtain a valid license.  启用方法：\n  搜索z.app.msgDialog, 可以看到包含它的是一个判断。\n if('balabalabalabalabala...') //这个判断很长 显示这是Demo版本，不能用这个功能; else 执行指令;  那我们要做的就是只留下需要执行的指令就可以了。 这一步完成，就可以从临时文件中移动文件了。\n  和第1步类似，搜索y.msgDialog,同样包含它的是一个判断，不同的是这个判断体的else部分执行了多条指令。删除判断只留下指令就可以了。\n这一步完成，就可以在各个文件夹中移动文件了。\n  这样文件的移动功能就可以正常使用了。我好像太坏了。\n","description":"","tags":["J2EE","CKFinder","CKEditor"],"title":"去除CKFinder版权信息以及启用文件移动功能","uri":"/posts/remove-ckfinder-copyright/"},{"categories":null,"content":"Apache Shiro用于权限管理十分方便，但存在一个问题，就是当用户的权限发生变化的时候，就需要用户重新登录，重新缓存用户的权限信息。\n现在想要在改变用户的权限的时候，清理用户的权限。 在写的过程中查找了一些资料，但是并没有成功实现权限的清理，所以我进行了一些修改，并实现了Helper类。\n我写的帮助类：\npackage com.zhaoyang.core.feature.security; import org.apache.shiro.SecurityUtils; import org.apache.shiro.cache.Cache; import org.apache.shiro.cache.CacheManager; import org.apache.shiro.subject.SimplePrincipalCollection; import org.apache.shiro.subject.Subject; import org.slf4j.Logger; import org.slf4j.LoggerFactory; /** * @author zhaoyang * * @since 2017-04-04 2:12 PM */ public class ShiroAuthorizationHelper { //shiro 配置的cacheManager， 需要使用Spring bean进行注入 private static CacheManager cacheManager; private static Logger logger = LoggerFactory.getLogger(ShiroAuthorizationHelper.class); /** * 清除用户的权限 * * 这里需要注意的是， * 网上很多实现都是这里只传递一个String类型的username过来，根据这个String当key去清除Cache * 但是Shiro在缓存用户权限的时候使用的key并不是String类型，所以调用remove的时候并不能清除缓存的权限 * * shiro缓存时使用的key，是登录时使用的SimplePrincipalCollection对象，所以remove的时候需要的不是一个String值， * 具体可以参考下面方法中打印cache的key的过程, 可以看到打印出key的类是 `class org.apache.shiro.subject.SimplePrincipalCollection` * 所以你cache.remove(String username)肯定清除不了 * * @param principal */ public static void clearAuthorizationInfo(SimplePrincipalCollection principal) { logger.info(\"clear the user: \" + principal.toString() + \"'s authorizationInfo\"); Cache\u003cObject, Object\u003e cache = cacheManager.getCache(\"myShiroCache\");//myShiroCache是我配置用于缓存的cache的Name，在spring配置文件中配置，可以看文章最后 // for (Object k : cache.keys()) { // System.out.println(k.getClass()); // } cache.remove(principal); } /** * 清除当前用户的权限 */ public static void clearAuthorizationInfo() { if (SecurityUtils.getSubject().isAuthenticated()) { Subject subject = SecurityUtils.getSubject(); String username = subject.getPrincipal().toString(); String realmName = subject.getPrincipals().getRealmNames().iterator().next(); SimplePrincipalCollection principalCollection = new SimplePrincipalCollection(username, realmName); // 调用清理用户权限 clearAuthorizationInfo(principalCollection); } } /** * 由Spring bean将对象注入 * @param cacheManager */ public static void setCacheManager(CacheManager cacheManager) { ShiroAuthorizationHelper.cacheManager = cacheManager; } }  将cacheManager注入到帮助类：\n \u003c!-- 注入Shiro帮助类的cacheManager --\u003e \u003cbean class=\"org.springframework.beans.factory.config.MethodInvokingFactoryBean\"\u003e \u003cproperty name=\"staticMethod\" value=\"com.damaiya.DMYSite.core.feature.security.ShiroAuthorizationHelper.setCacheManager\"/\u003e \u003cproperty name=\"arguments\" ref=\"shiroEhcacheManager\"/\u003e \u003c/bean\u003e  当然ref=“shiroEhcacheManager”需要你自己去实现, 我这里贴下我的：\n \u003c!-- 缓存管理器 使用Ehcache实现 --\u003e \u003cbean id=\"shiroEhcacheManager\" class=\"org.apache.shiro.cache.ehcache.EhCacheManager\"\u003e \u003cproperty name=\"cacheManagerConfigFile\" value=\"classpath:ehcache-shiro.xml\"/\u003e \u003c/bean\u003e  下面是ehcache-shiro.xml配置, 具体的参数作用我就不说了:\n\u003cehcache updateCheck=\"false\" name=\"shiroCache\"\u003e \u003cdefaultCache maxElementsInMemory=\"10000\" eternal=\"false\" timeToIdleSeconds=\"120\" timeToLiveSeconds=\"120\" overflowToDisk=\"false\" diskPersistent=\"false\" diskExpiryThreadIntervalSeconds=\"120\" /\u003e \u003ccache name=\"myShiroCache\" maxElementsInMemory=\"10000\" eternal=\"false\" timeToIdleSeconds=\"30\" timeToLiveSeconds=\"0\" overflowToDisk=\"false\" diskPersistent=\"false\" diskExpiryThreadIntervalSeconds=\"120\"/\u003e \u003c/ehcache\u003e  使用指定Name的Cache进行权限缓存配置, securityRealm是我自己的Realm：\n\u003cbean id=\"securityRealm\" class=\"com.damaiya.DMYSite.web.security.SecurityRealm\"\u003e \u003cproperty name=\"authorizationCacheName\" value=\"myShiroCache\"/\u003e \u003c/bean\u003e  这样整个配置就完成了，而且调用clearAuthorizationInfo()时就可以清除当前登录用户的权限信息了。\n","description":"","tags":["J2EE","Shiro"],"title":"Shiro清除更新缓存的用户权限","uri":"/posts/shiro-clear-update-authorization/"},{"categories":null,"content":"在J2EE项目中使用Shiro进行权限验证后，每次部署跳转到登录界面总会在链接后面多出;JSESSION=xxxx，查了很多，大概有下面几种方法：\n  在web.xml中添加以下代码：\n \u003csession-config\u003e \u003ctracking-mode\u003eCOOKIE\u003c/tracking-mode\u003e \u003c/session-config\u003e  具体请参考：\nhttp://stackoverflow.com/questions/11327631/remove-jsessionid-from-url\n   使用Filter对URL进行rewrite\n具体请参考：\nhttp://dr-yanglong.github.io/2015/07/07/del-jeesessionid/\n  有些同学重写了shiro重定向时需要调用的方法encodeRedirectURL()和toEncoded()\n具体请参考：\nhttp://dwangel.iteye.com/blog/2275899\nhttp://alex233.blog.51cto.com/8904951/1856155\n  后来去看了源码，发现了一个最最简单的方法，如下：\nshiro源码：\nhttps://github.com/apache/shiro/pull/31/commits/7f37394c6048d8c8a214eabd312721ddb51adc9b\n  阅读源码之后，可以发现DefaultWebSessionManager.java文件中添加了新属性private boolean sessionIdUrlRewritingEnabled;, 顾名思义, 是用来控制是否重写URL添加SESSIONID的，只要修改shiro的sessionManager配置如下即可：\n \u003cbean id=\"sessionManager\" class=\"org.apache.shiro.web.session.mgt.DefaultWebSessionManager\"\u003e ... \u003cproperty name=\"sessionIdUrlRewritingEnabled\" value=\"true\"/\u003e ... \u003c/bean\u003e  More Source： https://fralef.me/tomcat-disable-jsessionid-in-url.html\n","description":"","tags":["J2EE","Shiro"],"title":"最简单方法解决使用Shiro后URL中JSESSIONID的问题","uri":"/posts/tomcat-shiro-disable-jsessionid-in-url/"},{"categories":null,"content":"grep 概述 在给出文件列表或标准输入后, grep会对匹配一个或多个正则表达式的文本进行搜索, 并输出匹配（或者不匹配）的行或文本.\n使用格式 grep [options] PATTERN [FILE...]  常用选项  -i 忽略字符大小写 -v 显示未被模式匹配到的行或串 -o 只显示匹配到的串而不是整行 -n 显示匹配的行及行号 -E 使用扩展的正则表达式 -A n 显示出匹配到的行和后n行 -B n 显示出匹配到的行和前n行 -C n 显示出匹配到的行和前后各n行  扩展的正则表达式\n扩展正则表达式与基础正则表达式的唯一区别在于: () {} ? + 这几个字符.\n基础正则表达式中, () {} ? + 表示特殊含义，使用时需要将他们转义\n而扩展正则表达式中, () {} ? + 不表示特殊含义, 你需要将他们转义.\n转义符号, 都是一样的: 反斜线 \\ .\n所谓特殊含义, 就是正则表达式中的含义. 非特殊含义, 就是这个符号本身.\n正则表达式 元字符          . 匹配任意单个字符   [] 匹配[]指定范围内的任意单个字符   [^] 匹配[]指定范围外的任意单个字符    字符集          [:digit:] 数字   [:lower:] 小写字母   [:upper:] 大写字母   [:punct:] 标点符号   [:space:] 空白字符   [:alpha:] 所有字母   [:alnum:] 所有字母和数字, 非标点    例1.1\n$ grep '[[:punct:]]' grep_example # 所有有标点的行  匹配次数          .* 匹配任意字符串   * 前面的字符重复任意次数, 0次1次或多次   + 前面的字符重复1次或多次   ? 前面的字符重复0次或者多次   {m, n} 匹配前面的字符至少m次, 至多n次   {m, } 匹配前面的字符至少m次    位置锚定 ||| | ^ | ^后面的字符必须出现在行首 | | $ | $前面的字符必须出现在行尾 | | ^$ | 空白行 | | \u003c | \u003c后面的字符必须出现在词首 | | \u003e | \u003e前面的字符必须出现在词尾 | | () | ()中的当做一个整体匹配 |\n例1.2\n$ grep -E '.*(d+)' grep_example $ grep -E '.*(d+)$' grep_example  sed 概述 sed (意为流编辑器, 源自英语\"Stream Editor\"的缩写)\nsed用来把文档或字符串里面的文字经过一系列编辑命令转换为另一种格式输出.\nsed通常用来匹配一个或多个正则表达式的文本进行处理.\n模式空间\n模式空间: 把当前处理的行存储在临时的缓冲区, 称为\"模式空间\"(Pattern Space)\n模式空间就是读入行所在的缓存，sed对文本行进行的处理都是在这个缓存中进行的。\n使用格式 sed 'Address Command' [FILE...]  常用选项  -n 不显示模式空间中的内容 -i 直接修改原文件 -r 使用扩展的正则表达式  Address 1. StartLine, EndLine: # 开始行, 结束行 # 如: 1, 100 表示 1 到 100 行 2. /RegExp/ # 正则表达式 3. /pattern1/, /pattern2/ # 从匹配到/pattern1/开始, 一直到匹配到/pattern2/结束中间所有的行 4. LineNumber # 指定的某一行 5. StartLine, +N # 从StartLine开始后面N行  Command  d 删除满足模式的行 p 显示满足模式的行 a \\string 在满足模式的行后添加新行, 内容为string串的内容 i \\string 在满足模式的行前添加新行, 内容为string串的内容 r file：将指定的文件的内容添加至符合条件的行后 w file：将地址指定范围内的行另存至指定的文件中 s \\pattern\\string\\修饰符 将满足pattern的串替换为string 修饰符: \\g 全局替换, 即将该行中所有匹配项替换, 默认只替换第一个匹配项 \\i 忽略大小写 \u0026 引用模式匹配的整个串 \\1 表示匹配到模式中的第一个 ( 开始的串 \\2 表示匹配到模式中的第二个 ( 开始的串  例2.1\n#从以hezhaoyang开头的行开始匹配, 一直到以I开头的行, 显示中间所有行 $ sed -n '/^hezhaoyang/,/^I/p' sed_example  例2.2\n#将sed_insert中的内容插入到以hezhaoyang开头的行后 $ sed '/hezhaoyang/r sed_insert' sed_example  awk 概述 AWK是一种处理文本文件的语言. 它将文件作为记录序列处理. 在一般情况下，文件内容的每行都是一个记录. 每行内容都会被分割成一系列的域, 因此, 我们可以认为一行的第一个词为第一个域,第二个词为第二个, 以此类推. AWK程序是由一些处理特定模式的语句块构成的. AWK一次可以读取一个输入行. 对每个输入行, AWK解释器会判断它是否符合程序中出现的各个模式, 并执行符合的模式所对应的动作。\n——阿尔佛雷德·艾侯，The A-Z of Programming Languages: AWK\n使用格式 awk [options] 'BEGIN{ } pattern{ } END{ }'  常用选项  -F fs : 指定分隔符为fs -v var=value : 定义可传递给awk的变量 -f scriptfile : 从脚本文件中读取awk命令  基本结构 一个awk脚本通常由: BEGIN语句块、能够使用模式匹配的通用语句块、END语句块3部分组成, 这三个部分是可选的. 任意一个部分都可以不出现在脚本中, 脚本通常是被单引号或双引号中.\nawk 的工作过程 第一步: 执行BEGIN{ commands }语句块中的语句; 第二步: 从文件或标准输入(stdin)读取一行, 然后执行pattern{ commands }语句块, 它逐行扫描文件, 从第一行到最后一行重复这个过程, 直到文件全部被读取完毕. 第三步: 当读至输入流末尾时, 执行END{ commands }语句块.\nBEGIN语句块在awk开始从输入流中读取行之前被执行, 这是一个可选的语句块, 比如变量初始化、打印输出表格的表头等语句通常可以写在BEGIN语句块中. END语句块在awk从输入流中读取完所有的行之后即被执行, 比如打印所有行的分析结果这类信息汇总都是在END语句块中完成, 它也是一个可选语句块. pattern语句块中的通用命令是最重要的部分, 它也是可选的. {} 相当于一个循环体, 它会对文件中的每一行进行迭代.\n输出 print / printf print   当要输出多个变量时, 应该用逗号',‘分隔\n $ echo | awk '{ var1=\"v1\"; var2=\"v2\"; var3=\"v3\"; print var1,var2,var3; }'    只写 print 相当于 print $0, 如果想要输出空行, 应该写做: print ''\n  $1, $2, $3 … 分别对应该行的第1个, 第2个, 第3个字段, 以此类对\n  printf 与 print 的区别在于 printf 需要格式化输出.\n         %c 字符类型   %d, %i 十进制   %e, %E 科学计数法输出数值   %f 浮点数类型   %g, %G 科学计数法或浮点数格式显示   %s 字符串   %u 无符号整数   %% %本身    修饰符  N: 宽度 -: 左对齐 +: 显示数值符号  注意: printf 默认不换行, 需要使用\"\\n\"\n例3.1:\n#输出用户名和使用的shell类型 $ head -10 /etc/passwd | awk -F: '{printf \"%-15s%s\\n\", $1, $7}'  awk内置变量 记录变量  FS: field separator 字段分隔符, 默认为空白字符 RS: record separator 记录分隔符, 默认为换行符 OFS: output field separator 输出字段分隔符 ORS: output record separator 输出记录分隔符  数据变量   NR: number of input rows 处理的行数\n  NF: number of fields 该行字段的个数\n  ARGV: 数组, 保存awk命令行. 如: $ awk ‘{ print $0 }’ a.txt b.txt中ARGV[0]=awk, ARGV[1]=a.txt\n  ARGC: awk命令参数的个数\n  FILENAME: 所处理文件的名称\n  IGNORECASE: IGNORECASE=1时忽略大小写\n $ echo \"TEST HHHH\" | awk '{IGNORECASE=1; if($1 == \"test\"){print \"ok\";}}'    赋值 $ awk -v var=\"value\" '{print var}' $ awk 'BEGIN{ var=\"value\"; print var; }'  操作符 + - * / ^ ** %  比较运算符  \u003c \u003c= \u003e= \u003e \u003e= == != x~y # True if the string x matches the regexp denoted by y # 如果字符串x被正则表达式y匹配, 则为真 x!~y  数组 定义 arr[1] = 'first' arr[2] = 'second' arr['year'] = 2016 arr['month'] = 8  长度 length() 获取字符串，数组的长度 split() 分割数组， 返回长度 asort() 排序数组， 返回长度  需要注意：\n判断数组是否包含某键值\n#错误写法 $ echo | awk 'BEGIN{a[\"a\"]=1;a[\"b\"]=2; if(a[\"c\"]!=1){print \"ok\"}; for(i in a) {print i, a[i];} }' #正确判断 $ echo | awk 'BEGIN{a[\"a\"]=1;a[\"b\"]=2; if(\"c\" in a){print \"ok\"}; for(i in a) {print i, a[i];} }'  awk 中的数组是关联数组, 只要是通过他的数组引用过key, 就会自动创建该序列.\n多维数组 awk的多维数组本质上是一维数组, 更确切地说, awk是不支持以为多维数组的. 但是awk提供了逻辑上模拟多维数组的方式. 在awk中, array[1, 2]=1 , 这样的写法是允许的. 他是使用了一个特殊字符串SUBSEP(\\034)分隔键, [2, 4]实际上是[2SUBSEP4].\n访问可以使用for( (i, j) in array ){}但是必须用圆括号. 但是单独访问时, 必须使用split()将数组键值分开. 即:\narr[1,1] = 11; arr[1,2] = 12; arr[2,1] = 21; arr[2,2] = 22; for (a in arr) { split(a, tmp, SUBSEP); print tmp[1], tmp[2];z }  控制语句 1. if-else if (condition) {} else {} 2. while while (condition) {} 3. do-while do {} while (condition) 4. for for ( ; ; ) {} for (item in array) {} 5. switch switch (expression) { case x: ; case y: ;} 6. break, continue 7. next # 提前结束本行  内置函数 split(string, array [,fieldsep]) # 使用fieldsep分隔string, 并存储在名为array的数组中 #实例: $ awk '{ split( \"20:18:00\", time, \":\" ); print time[2] }' # 上例把时间按冒号分割到time数组内，并显示第二个数组元素18。 # 返回值为分割数组的长度 length(string) substr(string, start [, length]) system(command) : 执行命令并返回给awk systime() : 返回当前时间时间戳 tolower(string) toupper(string) match(string, regular expression) # match函数返回在字符串中正则表达式位置的索引, # 如果找不到指定的正则表达式则返回0, 找到返回1。 # match函数会设置内建变量RSTART为字符串中子字符串的开始位置, RLENGTH为到子字符串末尾的字符个数. # substr可利于这些变量来截取字符串. #实例： $ awk '{start=match(\"this is a test\",/[a-z]+$/); print start}' $ awk '{start=match(\"this is a test\",/[a-z]+$/); print start, RSTART, RLENGTH }' # 第一个实例打印以连续小写字符结尾的开始位置, 这里是11. # 第二个实例还打印RSTART和RLENGTH变量, 这里是11(start), 11(RSTART), 4(RLENGTH).  内建数学函数 1. cos(x) 余弦函数 2. exp(x) 求幂 3. int(x) 取整 4. log(x) 自然对数, 过程没有舍入 5. rand() 产生一个大于等于0而小于1的随机数 6. sin(x) 正弦 7. sqrt(x) 平方根 8. srand(x) x是rand()函数的种子  自定义函数 function F_NAME([variable]) { statements } # 函数还可以使用return语句返回值，格式为“return value” ","description":"","tags":["Linux"],"title":"Grep, Sed, Awk 日常使用","uri":"/posts/grepsedawk/"},{"categories":null,"content":"前言 没有接触过Vim的同学, 一定会觉得平时使用的IDE很好用, 但是当你开始使用Vim, 并且渐渐熟悉, 我觉得你会爱上这一款编辑器. 千万不要因为一开始Vim有太多命令需要记忆而放弃它.\n这篇博客是翻译自《Learn Vim Progressively》, 并在我觉得有必要添加说明的地方添加了自己的说明. 我认为是最适合入门Vim的教程, 没有之一.\n 正文开始 你想以最快的方式自学Vim吗? 在人类最优秀的编辑器面前, 你必须至少先学会如何幸存下来, 然后再去一点点整合使用它的技巧.\nVim the Six Billion Dollar editor\n Better, Stronger, Faster\n 当你学会使用Vim, 它将成为你最后一个编辑器. 虽然学习它的过程很不容易, 但是最后它会难以置信的好用.\n下面4个步骤是你自学的感受:\n 存活 使用顺手 更好, 更强, 更快 使用Vim的超能力  当你读完这篇文章, 你将会爱上vim.\n但是我们开始之前, 要先说明一点:\n 学习vim的过程将是十分痛苦的 将花费一些时间, 千万不要觉得浪费时间儿放弃 学习他的过程就像是学习乐器, 一旦入门, 就会变得很轻松 不要奢望像其他编辑器一样三天之内就能熟练掌握, 学习vim至少需要两个星期而不是三天  Level 1 - 存活 安装vim 运行vim 不要做任何事情! 请先阅读  在普通编辑器中, 当你敲击键盘就能在屏幕上看到想要的字符. 但是对于Vim来讲, 不是这样的. 当你启动vim的时候, vim当前正在 Normal 模式下, 你需要先将模式切换为 Insert 模式, 才能够输入字符. 从 Normal 模式到 Insert 模式, 需要敲击键盘字符 i.\n当你进入*Insert*模式, 你可能会感觉舒服一点, 因为你可以像普通编辑器一样输入字符了. 如果你想从*Insert*模式切换回*Normal*模式, 只需要敲击键盘最左上角的键ESC键.\n现在你知道如何在*Insert*模式和*Normal*模式之间切换了. 现在, 你必须要掌握下面几个命令以保证你能在*Normal*模式下存活下去:\n  i : 切换到*Insert*模式. 按ESC返回*Normal*模式 x : 删除当前光标所在的一个字符 :wq : 保存并退出 (:w 保存编辑的文件, :q 退出vim) dd : 删除光标所在的一行 p : 粘贴    #####推荐\n   hjkl (强烈推荐但不强制使用): 你可以使用键盘的 ↑ ↓ ← → 进行光标的移动. 提示: 在*Normal*模式下, j代表方向 ↓ :help \u003ccommand\u003e : 显示 \u003ccommand\u003e 的帮助文档. 你可以直接输入 :help 而不输入 \u003ccommand\u003e 获取一般性帮助.   最开始, 你只需要上面5个命令. 当你很自然地使用以上命令, 抛弃之前普通编辑器的习惯, 那么你就可以到Level 2了.\n但是, 在*Normal*模式下需要注意的是: 在普通编辑器下, Ctrl-C是复制命令, 这是个组合按键来完成一项复制的功能, 但是在vim下, 不可以轻易地使用Ctrl. 事实上, 在Vim的 *Normal* 模式下, vim已经赋予每一个按键功能, 也就是说, 在*Normal*模式下, 每一个键都是功能键, 而不需要你按下Ctrl去组合其他按键实现某项功能.\n提示\n 为了便于书写和阅读, 下面的文章中, \u003cC-λ\u003e 将代表键入 Ctrl-λ 命令都是以:开头, 并且最后要键入\u003center\u003e. 如: 当我写:q, 将代表:q\u003center\u003e  Level 2 - 感觉顺手 你现在已经可以在vim中存活了. 现在是时候学点其他的命令了. 下面是我的建议(以下命令都是在*Normal*模式下键入):\n 各种插入模式    a : 在当前光标后开始插入, 并且进入*Insert*模式 o : 从当前行下面插入新行, 并且进入*Insert*模式 O : 从当前行上面插入新行, 并且进入*Insert*模式 cw : 删除光标开始的单词, 并且进入*Insert*模式   基本的移动    0 : 到光标所在行的最开始 ^ : 到光标所在行第一个非空字符 $ : 到光标所在行的末尾 g_ : 到光标所在行最后一个非空字符 /pattern : 向下搜索字符串pattern ?pattern : 向上搜索字符串pattern  注: 搜索时, 键入n键可以查看下一项, 键入N键可以查看上一项\n 复制/粘贴    p : 在当前光标后粘贴 P : 在当前光标前粘贴 yy: 复制光标所在整行   撤销/恢复 (Undo/Redo)    u : 撤销 \u003cC-r\u003e : 恢复   载入/保存/退出/修改文件(Buffer)   :e \u003cpath/to/file\u003e : 打开文件 :w : 保存文件修改 :saveas \u003cpath/to/file\u003e : 另存为\u003cpath/to/file\u003e :x, ZZ or :wq : 保存并退出. :wq相当于先:w再:q; :x只在需要时保存; ZZ不需要输入:和回车\u003center\u003e :q! : 强制退出而不保存修改. :qa!, 强制退出所有正在编辑的文件, 即使其他文件有做过修改而没有保存 :bn和:bp : 切换到下/上一个文件\n 花一点时间去熟悉上面的命令. 当你熟练掌握之后, 你可以完成你在普通编辑器几乎所有功能. 你可能会觉得用vim还是有点别扭. 但是跟着我进入下一Level, 或许你可以明白为什么要花费这么多力气去学习它.\nLevel 3 - 更好. 更强. 更快. 恭喜你已经到达了Level 3! 我们现在开始学习一些有趣的东西. 在Level 3, 我们只讨论和vi编辑器兼容的那些命令.\n3.1 更好 让我们看看vim是怎么样帮助你做重复的命令的:\n .(点) : 重复上一次的命令 N\u003ccommand\u003e: 将会运行\u003ccommand\u003eN次, 这里的N是一个整数  下面是一个例子. 打开一个文件然后输入下面的命令:\n  2dd : 将会删除2行 3p : 将会执行粘贴命令3次 100idesu [ESC] : 将会输入 “desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu” . : 跟在上一个命令后面代表再次输入100次\"desu\" 3. : 将会输入3次\"desu\"(而不是300次, 你看vim多么聪明)   3.2 更强 知道如何高效的在vim中移动光标十分重要. 不要跳过这一部分.\n NG : 移动光标到第N行 gg : 相当于 1G, 到文件的最开始一行 G : 到文件的最后一行 按照单词移动:    w : 到下一个单词的开始 e : 到下一个单词的结尾 默认情况下, 我们认为单词是由一系列字符和下划线组成. 如果你认为由空格分隔开的字符串即为单词, 那么你只需要使用W和E.     现在介绍更高效的移动方式:\n  % : 匹配括号移动光标, 如(),[],{} *和# : 匹配光标当前所在单词, 并且向下/上查找匹配的单词, 并把光标移到查找到的单词   相信我, 最后的三个命令是十分高效的.\n3.3 更快 记住如何移动光标了吗, 因为很多命令都是可以组合使用的. 并且大多是以以下格式:\n\u003cstart position\u003e\u003ccommand\u003e\u003cend position\u003e\n例如: 0y$ 意思是\n 0 : 将光标移动到行首 y : 开始复制 $ : 复制到行尾  我们也可以使用ye, 从光标所在位置复制到单词结束. 也可以使用y2/foo, 从光标所在位置复制到匹配的第二个foo\n对y(复制)来说是这样的, 那么对d(删除), v(可视化选择), gU(转大写), gu(转小写)等等命令来说也是同样适用的\nLevel 4 - 适用Vim的超能力 «未完待续»\n","description":"","tags":["vim"],"title":"Vim 初级入门","uri":"/posts/how-to-use-vim/"},{"categories":null,"content":" 谓词（NSPredicate）提供在Cocoa中指定查询的普通解决方案。NSPredicate类用于定义逻辑条件以限制或筛选获取结果。\n NSPredicate 的基本使用 定义： NSPredicate *predict = [NSPredicate predicateWithFormat: @\"SELF CONTAINS[cd] %@\", SOMESTRING];  常用方法：    关键字 效果     比较运算符    \u003e,\u003c,==,\u003e=,\u003c=,!= 左侧满足比较运算符   字符相关    BEGINSWITH 左侧表达式 以 右侧表达式 开始   ENDSWITH 左侧表达式 以 右侧表达式 结束   CONTAINS 左侧表达式包含右侧表达式   范围相关    BETWEEN 左侧表达式在右侧表达式范围内   IN 左侧表达式在右侧表达式内   正则表达式    MATCHES 左侧表达式满足右侧表达式，右侧为正则表达式   通配符    LIKE 左侧表达式等于右侧表达式: 允许将 ? 和 * 用作通配符,其中 ? 匹配一个字符,而 * 匹配零个或多个字符    字符串 NSString *originStr = @\"I like shangha!\"; NSString *str = @\"shanghai\"; NSPredicate *predict = [NSPredicate predicateWithFormat: @\"SELF CONTAINS %@\", str]; if ([predict evaluateWithObject:originStr]) { NSLog(@\"含有字符串%@\", str); }  其中 CONTAINS 也可以替换为 BEGINSWITH,ENDSWITH。 在它们后面，可以在方括号中添加c、d 或 cd, 如CONTAINS[cd],其中c代表不区分大小写, d代表不区分音调符号。\n数组和字典 谓词常用于数组的筛选:\n NSArray *mArray = [NSArray arrayWithObjects:@\"beijing\", @\"shanghai\", @\"shenzhen\", @\"guangzhou\", nil]; //IN 用法 NSPredicate *predicate1 = [NSPredicate predicateWithFormat:@\"SELF IN {'shanghai', 'guangzhou'}\"]; NSArray *filteredArray1 = [mArray filteredArrayUsingPredicate: predicate1]; NSLog(@\"筛选后数组为:%@\", filteredArray1); //LIKE 用法 NSPredicate *predicate2 = [NSPredicate predicateWithFormat:@\"SELF LIKE '*h*'\"]; NSArray *filteredArray2 = [mArray filteredArrayUsingPredicate: predicate2]; NSLog(@\"筛选后数组为:%@\", filteredArray2);  谓词的条件也可以通过字典的占位符实现:\nNSPredicate *p1 = [NSPredicate predicateWithFormat:@\"name==$NAME AND price==$PRICE\"]; NSDictionary *dic = [NSDictionary dictionaryWithObjectsAndKeys:@\"name5\", @\"NAME\", @\"5000\", @\"PRICE\", nil]; NSPredicate *p2 = [p1 predicateWithSubstitutionVariables:dic]; //表示从cars数组中筛选满足 name='name5' AND price='5000' 条件的元素 NSArray *filteredCars = [cars filteredArrayUsingPredicate:p2];  ","description":"","tags":["iOS"],"title":"NSPredicate(谓词) 的使用","uri":"/posts/predicateuse/"},{"categories":null,"content":"  什么是WebWorker\nweb worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。我们知道页面的展示放在主线程，如果让主线程进行一系列复杂的操作，那么页面就会变得非常卡，用户体验会很差。这是我们可以使用web worker进行复杂操作的实现，然后将处理结果返回给页面，页面进行更新即可，这样就不会影响用户主页面展示的执行。\n  方法： postMessage() : 用于向HTML页面返回消息 terminate() : 终止web worker， 并且释放资源\n  实现方法： Demo: 数字从0开始累加\nindex.html \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript src=\"index.js\"\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"numDiv\"\u003e0\u003c/div\u003e \u003c/body\u003e \u003c/html\u003e  index.js var numDiv; window.onload = function() { numDiv = document.getElementById(\"numDiv\"); var worker = new Worker(\"webWorker.js\");//创建Worker对象 worker.onmessage = function (e) { numDiv.innerHTML = e.data; } }  webWorker.js var countNum = 0; function count () { postMessage(countNum);//给html页面返回数据 countNum ++;//数字累加 setTimeout(count, 1000);//一秒执行一次 } count();//调用函数执行 ","description":"","tags":["HTML5","WebWorker"],"title":"HTML5 WebWorker 简单使用","uri":"/posts/html5webworker/"},{"categories":null,"content":"  什么是应用缓存？\nHTML5引入了应用缓存概念，意味着在没有因特网连接时也可以进行访问。\n  使用应用缓存好处：\n 离线浏览，没有因特网的情况下依然可以进行访问 访问速度提升，已经缓存的资源加载更快 减少服务器负载，浏览器只需要下载更新过的页面资源    实现方法：\n如果需要使用应用缓存，需要在页面\u003chtml\u003e标签中包含 manifest 属性，而manifest文件建议使用文件扩展名.appcache。\n  Manifest文件功能：\n CACHE: 在此标题下列出的文件会在首次访问加载之后进行缓存； NETWORK: 在此标题下列出的文件需要与服务器连接、且不会被缓存； FALLBACK: 在此标题下列出的文件规定当页面无法访问时的退回页面（如404页面）    功能实现 index.html 请注意\u003chtml\u003e标签 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\" manifest=\"index.appcache\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003e\u003c/title\u003e \u003clink rel=\"stylesheet\" href=\"style.css\"\u003e \u003cscript src=\"index.js\"\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1 class=\"h1\"\u003eHELLO HMTL5\u003c/h1\u003e \u003c/body\u003e \u003c/html\u003e  style.css .h1 { color: red; background: blue; }  index.js /*空文件*/  index.appcache CACHE MANIFEST CACHE: index.html style.css index.js NETWORK: FALLBACK:  测试   开启本地服务器，在Chrome输入localhost/webCache\n  使用Chrome审查元素功能，切换到Resources功能标签，点击左侧Application Cache功能标签，可以观察到我们设置缓存的三个文件已经缓存成功\n  断开本地服务器，重新刷新页面，会发现页面样式仍然保持，说明缓存起作用了。\n ","description":"","tags":["HTML5","Cache"],"title":"HTML5应用缓存简单使用","uri":"/posts/html5webcache/"},{"categories":null,"content":"前文已经介绍了如何给UITableView添加搜索栏，这次要给UITableView进一步添加索引条。 基本思路：\n 获取总统名字的首字母组成一个索引字母表储存在数组中； 修改TableView的代理方法实现section的显示，section的数量应为索引字母表的元素的个数； 把索引条添加到TableView 中，用TableView的代理方法即可实现。  由于接着上文，所以本文中代码将不会全部展示，代码的重复部分将用省略号代替。\nStep1. 添加属性 在ViewController.h中添加属性：NSMutableArray *alphabetArray;\n#import \u003cUIKit/UIKit.h\u003e @interface ViewController : UIViewController ...\t@property (nonatomic, strong) NSMutableArray *alphabetArray; ...\t@end  Step2. 修改ViewController.m // // ViewController.m // UITableViewAdvanced01 // // Created by mungo on 19/03/16. // Copyright © 2016 mungo. All rights reserved. // #import \"ViewController.h\" #import \"President.h\" @interface ViewController () \u003cUITableViewDataSource, UITableViewDelegate, UISearchBarDelegate, UISearchResultsUpdating, UISearchDisplayDelegate\u003e @end @implementation ViewController - (void)viewDidLoad { [super viewDidLoad]; //初始化数据 ... //创建tableview ... //创建searchController ... //设置tableview的搜索栏 ... //设置字母表 self.alphabetArray = [self getAlphetSortedArray]; } /** * 新添加方法： * 获取字母表 * @return MSMutableArray* 已经排序的字母表数组 */ - (NSMutableArray *) getAlphetSortedArray { self.alphabetArray = [[NSMutableArray alloc] init]; for (int i = 0; i \u003c [self.presidents count]; i ++) { //获取名字的第一个字母 President *president = [self.presidents objectAtIndex:i]; char letter = [president.firstName characterAtIndex:0]; NSString *uniqueChar = [NSString stringWithFormat:@\"%c\", letter]; //将字母加入到字母表中 if (![self.alphabetArray containsObject:uniqueChar]) { [self.alphabetArray addObject:uniqueChar]; } } //对字母表进行排序 NSSortDescriptor *sortDescriptor = [[NSSortDescriptor alloc] initWithKey:@\"self\" ascending:YES]; NSArray *sortDescirptors = [NSArray arrayWithObject:sortDescriptor]; NSArray *sortedArray; sortedArray = [self.alphabetArray sortedArrayUsingDescriptors:sortDescirptors]; NSMutableArray *alphabetArray = [[NSMutableArray alloc] initWithArray:sortedArray copyItems:YES]; return alphabetArray; } #pragma mark - tableView Delegate - (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section { if (self.searchController.active) { ... } else { //根据section筛选以当前字母开头的总统数组 NSArray *tmpArray = [self getAlphabetArrayWithIndex:section]; return [tmpArray count]; } } #pragma mark - Indexing UITableView //索引条的字母表 - (NSArray\u003cNSString *\u003e *)sectionIndexTitlesForTableView:(UITableView *)tableView { return self.alphabetArray; } - (NSInteger) tableView:(UITableView *)tableView sectionForSectionIndexTitle:(NSString *)title atIndex:(NSInteger)index { return index; } #pragma mark - tableView Datasource - (NSInteger) numberOfSectionsInTableView:(UITableView *)tableView { if (self.searchController.active) { self.alphabetArray = nil;//搜索时不显示section return 1; } else { self.alphabetArray = [self getAlphetSortedArray];//停止搜索恢复section显示 return [self.alphabetArray count]; } } //tableView section的标题 - (NSString *) tableView:(UITableView *)tableView titleForHeaderInSection:(NSInteger)section { return [self.alphabetArray objectAtIndex: section]; } - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath { ... President *president; if (self.searchController.active) { ... } else { //根据section筛选以当前字母开头的总统数组 NSArray *tmpArray = [self getAlphabetArrayWithIndex:indexPath.section]; if ([tmpArray count]) { president = [tmpArray objectAtIndex:indexPath.row]; } } if (president) { cell.textLabel.text = [NSString stringWithFormat:@\"%@ %@\", president.firstName, president.lastName]; } return cell; } /* * 新添加方法： * 根据首字母对所有总统进行筛选 * @return NSArray* 于当前首字母相同的总统数组 */ - (NSArray *) getAlphabetArrayWithIndex:(NSInteger)index{ NSString *alphabet = [self.alphabetArray objectAtIndex:index]; NSPredicate *president = [NSPredicate predicateWithFormat:@\"firstName BEGINSWITH [cd] %@\", alphabet]; NSArray *tmpArray = [self.presidents filteredArrayUsingPredicate:president]; return tmpArray; } #pragma mark - SearchController delegate - (void)updateSearchResultsForSearchController:(UISearchController *)searchController { ... } @end  注意： numberOfSectionsInTableView中， 开始搜索的时候要将TableView的section数量设置为1，并且要把字母表设置为空；不搜索时要恢复section的数量。\n实现效果 ","description":"","tags":["iOS","UITableView"],"title":"UITableView使用简单进阶(二):索引条","uri":"/posts/uitableviewadvance02/"},{"categories":null,"content":"UITableView 是开发中使用十分频繁的控件，本系列记录UITableView的进阶使用：UITableView的搜索栏和字母索引表。\n不想看我废话的可以直接到gitHub仓库下载源码😏。 UITableView使用进阶gitHub源码\n搜索栏有两种实现方式，第一种是通过UISearchBar和UISearchDisplayController实现，第二种是通过UISearchController实现。而在iOS8.0之后，苹果官方推荐使用第二种方式。\n本文使用的是第二种方式（UISearchController），不过源码中也实现了第一种(UISearchBar+UISearchDisplayController)。关于UISearchBar和UISearchDisplayController的使用，可以参考我的另一篇文章：UISearchBar和UISearchDisplayController实现搜索栏\n本文先介绍UITableView的搜索栏（UISearchController），是一个显示美国总统的TableView。\nStep1. 创建President类 创建一个名为President的Objective-C类，它继承于NSObject类，用于保存总统的姓氏和名字。定义一个静态方法，用来创建President对象，并且对firstName和lastName赋值。\nPresident.h #import \u003cFoundation/Foundation.h\u003e @interface President : NSObject @property (nonatomic, retain) NSString *firstName; @property (nonatomic, retain) NSString *lastName; + (President *) presidentWithFirstName: (NSString *)firstname lastName: (NSString *)lastname; @end  President.m #import \"President.h\" @implementation President + (President *) presidentWithFirstName:(NSString *)firstname lastName:(NSString *)lastname { President *president = [[President alloc] init]; president.firstName = firstname; president.lastName = lastname; return president; } @end  Step2. 编写ViewController viewController.h #import \u003cUIKit/UIKit.h\u003e @interface ViewController : UIViewController @property (nonatomic, strong) UITableView *mTableView; @property (nonatomic, strong) NSArray *presidents;//所有总统 @property (nonatomic, strong) NSArray *filteredPresidents;//保存搜索结果 @property (nonatomic, retain) UISearchController *searchController;\t@end  viewController.m #import \"ViewController.h\" #import \"President.h\" @interface ViewController () \u003cUITableViewDataSource, UITableViewDelegate, UISearchBarDelegate, UISearchResultsUpdating, UISearchDisplayDelegate\u003e @end @implementation ViewController - (void)viewDidLoad { [super viewDidLoad]; //初始化数据 self.presidents = [[NSArray alloc] initWithObjects: [President presidentWithFirstName:@\"George\" lastName:@\"Washington\"], [President presidentWithFirstName:@\"John\" lastName:@\"Adams\"], [President presidentWithFirstName:@\"Thomas\" lastName:@\"Jeffeson\"], [President presidentWithFirstName:@\"James\" lastName:@\"Madison\"], [President presidentWithFirstName:@\"James\" lastName:@\"Monroe\"], [President presidentWithFirstName:@\"John Quincy\" lastName:@\"Adams\"], [President presidentWithFirstName:@\"Andrew\" lastName:@\"Jackson\"], [President presidentWithFirstName:@\"Martin\" lastName:@\"van Buren\"], [President presidentWithFirstName:@\"William Henry\" lastName:@\"Harrison\"], [President presidentWithFirstName:@\"John\" lastName:@\"Tyler\"], [President presidentWithFirstName:@\"James K\" lastName:@\"Polk\"], [President presidentWithFirstName:@\"Zachary\" lastName:@\"Taylor\"], [President presidentWithFirstName:@\"Millard\" lastName:@\"Fillmore\"], [President presidentWithFirstName:@\"Franklin\" lastName:@\"Pierce\"], [President presidentWithFirstName:@\"James\" lastName:@\"Buchanan\"], [President presidentWithFirstName:@\"Abraham\" lastName:@\"Lincoln\"], [President presidentWithFirstName:@\"Andrew\" lastName:@\"Johnson\"], [President presidentWithFirstName:@\"Ulysses S\" lastName:@\"Grant\"], [President presidentWithFirstName:@\"Rutherford B\" lastName:@\"Hayes\"], [President presidentWithFirstName:@\"James A\" lastName:@\"Garfield\"], [President presidentWithFirstName:@\"Chester A\" lastName:@\"Arthur\"], [President presidentWithFirstName:@\"Grover\" lastName:@\"Cleveland\"], [President presidentWithFirstName:@\"Bejamin\" lastName:@\"Harrison\"], [President presidentWithFirstName:@\"Grover\" lastName:@\"Cleveland\"], [President presidentWithFirstName:@\"William\" lastName:@\"McKinley\"], [President presidentWithFirstName:@\"Theodore\" lastName:@\"Roosevelt\"], [President presidentWithFirstName:@\"William Howard\" lastName:@\"Taft\"], [President presidentWithFirstName:@\"Woodrow\" lastName:@\"Wilson\"], [President presidentWithFirstName:@\"Warren G\" lastName:@\"Harding\"], [President presidentWithFirstName:@\"Calvin\" lastName:@\"Coolidge\"], [President presidentWithFirstName:@\"Herbert\" lastName:@\"Hoover\"], [President presidentWithFirstName:@\"Franklin D\" lastName:@\"Roosevelt\"], [President presidentWithFirstName:@\"Harry S\" lastName:@\"Truman\"], [President presidentWithFirstName:@\"Dwight D\" lastName:@\"Eisenhower\"], [President presidentWithFirstName:@\"John F\" lastName:@\"Kennedy\"], [President presidentWithFirstName:@\"Lyndon B\" lastName:@\"Johnson\"], [President presidentWithFirstName:@\"Richard\" lastName:@\"Nixon\"], [President presidentWithFirstName:@\"Gerald\" lastName:@\"Ford\"], [President presidentWithFirstName:@\"Jimmy\" lastName:@\"Carter\"], [President presidentWithFirstName:@\"Ronald\" lastName:@\"Reagan\"], [President presidentWithFirstName:@\"George H W\" lastName:@\"Bush\"], [President presidentWithFirstName:@\"Bill\" lastName:@\"Clinton\"], [President presidentWithFirstName:@\"George W\" lastName:@\"Bush\"], [President presidentWithFirstName:@\"Barack\" lastName:@\"Obama\"], nil]; CGRect appFrame = [[UIScreen mainScreen] bounds]; //创建tableview self.mTableView = [[UITableView alloc] initWithFrame:CGRectMake(0, 20, appFrame.size.width, appFrame.size.height - 20) style:UITableViewStylePlain]; self.mTableView.delegate = self; self.mTableView.dataSource = self; [self.view addSubview:self.mTableView]; //创建searchController self.searchController = [[UISearchController alloc] initWithSearchResultsController:nil]; self.searchController.searchResultsUpdater = self; self.searchController.dimsBackgroundDuringPresentation = NO; self.searchController.hidesNavigationBarDuringPresentation = NO; //设置tableview的搜索栏 self.mTableView.tableHeaderView = self.searchController.searchBar; } #pragma mark - tableView Delegate - (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section { if (self.searchController.active) { return [self.filteredPresidents count]; } else { return [self.presidents count]; } } #pragma mark - tableView Datasource - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath { static NSString *cellId = @\"cellId\"; UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:cellId]; if (!cell) { cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:cellId]; } President *president; if (self.searchController.active) { president = [self.filteredPresidents objectAtIndex:indexPath.row]; } else { president = [self.presidents objectAtIndex:indexPath.row]; } cell.textLabel.text = [NSString stringWithFormat:@\"%@ %@\", president.firstName, president.lastName]; return cell; } #pragma mark - SearchController delegate - (void)updateSearchResultsForSearchController:(UISearchController *)searchController { NSString *searchString = [self.searchController.searchBar text]; NSPredicate *predicate = [NSPredicate predicateWithFormat:@\"firstName CONTAINS[cd] %@ OR lastName CONTAINS[cd] %@\", searchString, searchString]; self.filteredPresidents = [self.presidents filteredArrayUsingPredicate:predicate]; //刷新表格 [self.mTableView reloadData]; } - (void)didReceiveMemoryWarning { [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated. } @end  实现效果 ","description":"","tags":["iOS","UITableView","搜索栏"],"title":"UITableView使用简单进阶(一):搜索栏","uri":"/posts/uitableviewadvanced01/"},{"categories":null,"content":"要实现tableview的搜索栏，实现方法有两种：第一种是UISearchBar和UIDisplayController结合起来实现，另一种是通过UISearchController实现。这里只介绍第一种：\n注意: UISearchBar和UISearchDisplay只推荐iOS8.0之前使用。 关于UISearchController的使用请跳转至： UITableView使用进阶(一):搜索栏\n使用的协议 需要使用四个协议，分别是\n\u003cUITableViewDelegate, UITableViewDataSource, UISearchBarDelegate, UISearchDisplayDelegate\u003e\n头文件 ViewController.h #import \u003cUIKit/UIKit.h\u003e @interface ViewController : UIViewController @property (nonatomic, strong) UITableView *mTableView; //搜索结果 @property (nonatomic, strong) NSArray *filterData; //全部数据 @property (nonatomic, strong) NSMutableArray *allData; @property (nonatomic, retain) UISearchDisplayController *searchDisplayController; @end  实现文件 ViewController.m #import \"ViewController.h\" @interface ViewController () \u003cUITableViewDelegate, UITableViewDataSource, UISearchBarDelegate, UISearchDisplayDelegate\u003e @end @implementation ViewController - (void)viewDidLoad { [super viewDidLoad]; //初始化数据 int count = 100; self.allData = [NSMutableArray arrayWithCapacity:count]; for (int i = 0; i \u003c count; i ++) { [self.allData addObject:[NSString stringWithFormat:@\"第%d行\", i]]; } //定义tableview CGRect appFrame = [[UIScreen mainScreen] bounds]; self.mTableView = [[UITableView alloc] initWithFrame:CGRectMake(0, 20, appFrame.size.width, appFrame.size.height - 20) style:UITableViewStylePlain]; self.mTableView.delegate = self; self.mTableView.dataSource = self; [self.view addSubview:self.mTableView]; //定义UISearchBar UISearchBar *mySearchBar = [[UISearchBar alloc] init]; mySearchBar.delegate = self; [mySearchBar setAutocapitalizationType:UITextAutocapitalizationTypeNone]; [mySearchBar sizeToFit]; self.mTableView.tableHeaderView = mySearchBar; //定义UISearchDisplayController self.searchDisplayController = [[UISearchDisplayController alloc] initWithSearchBar:mySearchBar contentsController:self]; self.searchDisplayController.delegate = self; [self.searchDisplayController setSearchResultsDataSource:self]; [self setSearchDisplayController:self.searchDisplayController]; } #pragma mark - UITableView Delegate - (NSInteger) numberOfSectionsInTableView:(UITableView *)tableView { return 1; } - (NSInteger) tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section { if (tableView == self.searchDisplayController.searchResultsTableView) { return [self.filterData count]; } else { return [self.allData count]; } } #pragma mark - UITableView DataSource - (UITableViewCell *) tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath { static NSString *cellid = @\"cellid\"; UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:cellid]; if (!cell) { cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:cellid]; } if (tableView == self.searchDisplayController.searchResultsTableView) { cell.textLabel.text = [self.filterData objectAtIndex:indexPath.row]; } else { cell.textLabel.text = [self.allData objectAtIndex:indexPath.row]; } return cell; } #pragma mark - UISearchDisplayController - (BOOL) searchDisplayController:(UISearchDisplayController *)controller shouldReloadTableForSearchString:(NSString *)searchString { NSPredicate *predicate = [NSPredicate predicateWithFormat:@\"SELF CONTAINS[cd] %@\", searchString]; self.filterData = [self.allData filteredArrayUsingPredicate:predicate]; return YES; } - (void)didReceiveMemoryWarning { [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated. } @end  实现效果 ","description":"","tags":["iOS","UITableView","搜索栏"],"title":"UISearchBar和UISearchDisplayController实现搜索栏","uri":"/posts/uisearchbar-uisearchdisplaycontroller/"},{"categories":null,"content":"- (UIImage *) stretchableImageWithLeftCapWidth:(NSInteger)leftCapWidth topCapHeight:(NSInteger)topCapHeight  这个函数是UIImage的一个类函数，它的功能是创建一个内容可拉伸，而边角不拉伸的图片。两个参数的含义分别为：不拉伸区域的宽度、不拉伸区域的高度。\n根据设置的宽度和高度，在像素点((leftCapWidth+1), (topCapWidth+1))开始左右扩展和上下拉伸。\n注意：   可拉伸范围是距离leftCapWidth+1的那一列像素和topCapHeight+1的那一横排像素。 如果设置参数为10和5，那么，图片左边10个像素和上边5个像素区域内不会被拉伸。而从(11, 5)开始扩展和拉伸。\n  只是对一个像素进行复制到一定宽度，而图像后面的剩余部分也不会被拉伸。\n //原始图片 UIImage *image = [UIImage imageNamed:@\"yoububble.png\"] ; UIImageView *imageView1 = [[UIImageView alloc] initWithImage:image]; [imageView1 setFrame:CGRectMake(10, 60, 40, 40)]; [self.view addSubview:imageView1]; //拉伸后图片 UIImage *strechImage = [image stretchableImageWithLeftCapWidth:10 topCapHeight:10]; UIImageView *imageView2 = [[UIImageView alloc] initWithImage:strechImage]; [imageView2 setFrame:CGRectMake(10, 120, 300, 100)]; [self.view addSubview:imageView2];    ","description":"","tags":["iOS"],"title":"stretchableImageWithLeftCapWith:(NSInteger)leftCapWidth topCapHeight:(NSInteger)topCapHeight","uri":"/posts/stretchableimagewithleftcapwidth/"},{"categories":null,"content":"- (UILabel *) getLabelHeightFixedWithText: (NSString *) text { UIFont *font = [UIFont boldSystemFontOfSize: 12.0f]; int width = 225, height = 10000; NSMutableDictionary *attrs = [[NSMutableDictionary alloc] init]; [attrs setObject: font forKey: NSFontAttributeName]; CGRect size = [text boundingRectWithSize:CGSizeMake(width, height) options: NSStringDrawingUsesLineFragmentOrigin attributes: attrs context: nil]; UILabel *label = [[UILabel alloc] initWithFrame: CGRectMake(0, 0, size.size.width, size.size.height)]; label.numberOfLines = 0;//一定要设置行数为0 label.font = font; label.lineBreakMode = NSLineBreakByWordWrapping; label.text = (text ? text : @\"\"); label.backgroundColor = [UIColor clearColor]; label.textColor = [UIColor blackColor]; return label; }  ","description":"","tags":["iOS","UILabel"],"title":"根据字数自适应高度的UILabel","uri":"/posts/uilabel-with-height-fixed/"},{"categories":null,"content":"简介 在编写Web程序时，表单的提交若密码使用明文提交会十分不安全，因此在浏览器端也要对密码进行加密处理。但是若只是在浏览器端处理了，而服务器没有再一次加密，也是不妥当的，因为\"中间人\"只要获取了浏览器端加密的密码，不需要进行处理也能进行登录。所以我一般的做法是在前端加密一次，在服务器再加密一次。密码加盐（salt）的问题等我先研究下再写一下。而浏览器端加密一般我都用javascript进行加密后再提交。下面是用javascript编写的base64加密，md5加密和sha1加密。使用方法也极其简单，只要在页面内引入相应js文件即可。\nbase64加解密 \u003c!DOCTYPE HTML\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003ctitle\u003ebase64加解密\u003c/title\u003e \u003cscript type=\"text/javascript\" src=\"base64.js\"\u003e\u003c/script\u003e \u003cscript\u003e var base64 = new Base64(); //加密 var base64encodeStg = base64.encode(\"hello world!\"); alert(\"base64encode:\" + base64encodeStg); //解密 var base64decodeStg = base64.decode(base64encodeStg); alert(\"base64decode:\" + base64decodeStg); \u003c/script\u003e \u003c/head\u003e \u003c/html\u003e  md5加密 \u003c!DOCTYPE HTML\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003ctitle\u003emd5加密\u003c/title\u003e \u003cscript type=\"text/javascript\" src=\"md5.js\"\u003e\u003c/script\u003e \u003cscript\u003e var hash = hex_md5(\"hello world!\"); alert(hash);\t\u003c/script\u003e \u003c/head\u003e \u003c/html\u003e  sha1加密 相对于前两个，sha1加密可能更安全\n\u003c!DOCTYPE HTML\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003ctitle\u003esha1加密\u003c/title\u003e \u003cscript type=\"text/javascript\" src=\"sha1.js\"\u003e\u003c/script\u003e \u003cscript\u003e var sha1 = hex_sha1(\"hello world!\"); alert(sha1); \u003c/script\u003e \u003c/head\u003e \u003c/html\u003e  相关文件下载 base64.js | md5.js | sha1.js 百度网盘分享\n","description":"","tags":["md5","base64","sha1","javascript","加密"],"title":"JS实现密码加密(base64, md5, sha1)","uri":"/posts/javascript-md5-base64-sha1/"},{"categories":null,"content":"站长之家（ChinaZ.com） 3月4日消息，昨日开始，国内知名图床服务网站贴图库首页和服务器部分地区出现了无法访问的情况。据站长之家了解，贴图库因被检测到非法内容，遭到网信办下令要求域名服务商易名中国将域名**clientHold（锁定）**处理。\n我博客上面的图片也全都放在贴图库上面的，今天刚回归博客就发现图片不能访问了。查过之后才贴图库被关闭了，不过我觉得官方应该能解决好这个事情，毕竟是国内知名图床服务网站，用户数量应该很多。我觉得会给用户一个满意的答复的。要不然我博客里面的图片怎么办啊。摔！\n","description":"","tags":["贴图库","网信办","记录"],"title":"贴图库被网信办关闭 官方：解决需要时间","uri":"/posts/tietuku-clienthold/"},{"categories":null,"content":"为了使保存的密码更安全， 我们应该实现一个NSString的分类，为密码创建一个MD5的哈希值，而且并把它保存在keychain中；keychain是在设备中保存关键数据的唯一安全的地方。\nstep1. 新建文件 新建文件，在模板列表中选择Objective-C Category项。单击Next按钮，输入“MD5”作为这个创建的分类的名字，然后在CategoryOn下拉菜单中选择NSString，表明是NSString的Category。\nstep2. 头文件 #import \u003cFoundation/Foundation.h\u003e @interface NSString (MD5) - (NSString *) MD5; @end  step3. 源文件 #import \"NSString+MD5.h\" #import \u003cCommonCrypto/CommonDigest.h\u003e @implementation NSString (MD5) - (NSString *) MD5{ //转化为UTF8格式字符串 const char *ptr = [self UTF8String]; //开辟一个16字节数组 unsigned char md5Buffer[CC_MD5_DIGEST_LENGTH]; //调用官方封装的加密方法, 将ptr开始的字符串存储到md5Buffer[]中 CC_MD5(ptr, strlen(ptr), md5Buffer); //转换位NSString并返回 NSMutableString *output = [NSMutableString stringWithCapacity: CC_MD5_DIGEST_LENGTH * 2]; for (int i = 0; i \u003c CC_MD5_DIGEST_LENGTH; i ++) { [output appendFormat: @\"%02x\", md5Buffer[i]]; } /* * `x`表示十六进制，%02 意思是不足两位用0补齐，如果多于2位则不影响 * NSLog(\"%02x\", 0x666); //输出 `666` * NSLog(\"%02x\", 0x3);\t//输出 `03` */ return output; } @end ","description":"","tags":["iOS","加密","MD5"],"title":"iOS NSString字符串MD5加密","uri":"/posts/ios-md5/"},{"categories":null,"content":"之前从接口获取数据后转换为NSDictionary然后执行writeToFile就可以写入文件成功，昨天在使用豆瓣电影Api时，出现了前几条请求的数据写入缓存成功，从某一次请求开始就总是写入不成功。因为我是用gcd方式请求数据的，我还以为是因为线程竞争的问题，但是写文件的原子操作我设置的YES啊。然后写进程锁试一下，然而仍然写入失败，后来我不用gcd以为能好，结果还是写入失败。后来翻资料，说好像如果NSDictionary中有自定义的object类型是不能写入文件的，比如像null，呵呵。但是我找了半天也没找到错误所在，然后也不太影响正常使用，就暂时放在一边了。\n结果今天出问题了，之前获取的是电影的列表信息，今天要写电影的详情页信息。写好后不断测试，结果有一条电影，一点进入详情就会崩溃。好了，设置好断点，一步步排查，最后NSLog导演头像的urlString时，找到了问题所在，导演的头像图片的url为null！终于找到了问题所在。那么可以解决了…\n我获取了该条目电影的id号，然后在浏览器中获取了他的json数据，果不其然，就是这个电影!《火云端》!\n然而我并没有想到有这么多null。\n经过百度，好像要写文件，NSDictionary里面的object必须是NSString，NSData，NSNumber，NSDate，NSArray，NSDictionary中的数据类型。不过我知道，含有null是万万不能的，混蛋。\n解决方案：NSDictionary -\u003e NSDate NSDictionary写文件之前，可以把它转换成NSData类型的数据，再执行写文件操作。 从文件读取时把读取出的NSData转换为NSDictionary就可以了。\n用到的方法 NSDictionary -\u003e NSData:\nNSData *data = [NSKeyedArchiver archivedDataWithRootObject:dictionary];  NSData -\u003e NSDictionary:\nNSDictionary *dictionary = (NSDictionary *)[NSKeyedUnarchiver unarchiveObjectWithData:data];  昨天的问题解决了，这样写时候，每一次都能写入缓存文件成功。\n今天的涉及到NSDictionary值的获取的部分，我都加了一个判断 if([theValue isKindOfClass:[NSNull class]])，然后进行相应处理就可以了。\n这个时iOS的一个归档方法，不仅仅能归档null，自定义的类型也是可以的。具体可以参见小白猪jianjian的博客-使用NSKeyedArchiver归档\n感想 生活中或者程序开发中，遇到了问题不一定非要立马解决，如果死钻牛角尖儿可能一直都解决不了，那时只能浪费时间。如果暂时放放，休息一会，再回来想解决办法可能就能想到解决方案。就像今天我解决我的问题一样，完全是机缘巧合。同时我们也应该发现，如果想做出好的软件，前期开发的投入很重要，但是后期的测试也很重要。功能做完之后我也是点击测试了不说几百次，几十次也是有了才发现了这个问题。\n最后给大家看下我做的电影影讯，嘿嘿，使用了豆瓣电影Api。\n","description":"","tags":["iOS"],"title":"NSDictionary含有null导致写文件(writeToFile)失败(豆瓣电影Api返回Json数据中含有null)","uri":"/posts/nsdictionarywritetofilefailedbecauseofcontainsnull/"},{"categories":null,"content":"上一篇已经实现了页面的布局，这一篇我们来实现界面的逻辑变换。主要用到的是scollView的两个代理方法。我们先看一下效果。\n1.实现点击顶部按钮切换底部详情页面 给顶部items的按钮添加target 在- (void) addFirstScrollViewOnView 方法中的for循环中，为每个button添加一个target，用于监听点击按钮的事件。\n [itemButton addTarget:self action:@selector(itemButtonClicked:) forControlEvents:UIControlEventTouchUpInside];  添加监听方法 我们应该知道当点击顶部item按钮时，底部详情页应该做相应的切换，同时按钮样式也改变。 大家可能注意到了需要用到按钮的tag值，所以我们同样在上一步的方法的for循环中为每个按钮设置tag值。\nitemButton.tag = 100 + i;//设置button的tag值  同时，需要添加一个实例变量：\n //记录当前被点击的按钮tag @property (nonatomic, assign) NSInteger currentButtonTag;  **(重要)**并在上一步方法的最后为它设置初始值为100，也就是当前点击的按钮为第一个。\ntips：不从1开始设置tag值的原因是因为前100可能有系统的控件占用 scrollView详情页切换：获取当前按钮的tag值，计算偏移量\n- (void) itemButtonClicked:(UIButton *)button { //**1.偏移底部详情scrollView NSInteger buttonTag = button.tag - 100;//获取点击按钮的tag self.secondScrollView.contentOffset = CGPointMake(buttonTag * KSCREEN_WIDTH, 0);//设置底部scrollview的内容偏移量 //**2.恢复前一个被点击的按钮的样式 UIButton *preClickedButton = (UIButton *)[self.view viewWithTag:self.currentButtonTag]; preClickedButton.titleLabel.font = [UIFont systemFontOfSize:14.0f]; [preClickedButton setTitleColor:[UIColor colorWithRed:0.4 green:0.4 blue:0.4 alpha:1.0] forState:UIControlStateNormal];//标题颜色 //**3.设置当前点击按钮样式 button.titleLabel.font = [UIFont systemFontOfSize:18.0f]; [button setTitleColor:[UIColor colorWithRed:1.0 green:0.3 blue:0.3 alpha:1.0f] forState:UIControlStateNormal]; //**4.改变当前点击按钮的tag值 self.currentButtonTag = buttonTag + 100; }  完成这一步，当你点击顶部按钮的时候，你就可以看到顶部按钮样式的改变和底部详情页面的切换。\n2.实现滚动底部详情页顶部按钮字体切换 添加scrollView的代理 添加代理\n@interface ViewController () \u003cUIScrollViewDelegate\u003e  在- (void) addSecondScrollViewOnView 方法中设置secondScrollView的代理为self。这步不要忘记了。\nsecondScrollView.delegate = self;  实现scrollView 的代理方法 - (void) scrollViewDidScroll:(UIScrollView *)scrollView； 在这一步，我们要实现滚动时，顶部items的按钮字体大小和颜色的改变。\n //正在滑动调用的代理方法 - (void) scrollViewDidScroll:(UIScrollView *)scrollView { //获取当前第二个scrollView的偏移量 CGFloat secondScrollViewContentOffsetX = scrollView.contentOffset.x; //获取选中按钮的序号 int buttonTag = (secondScrollViewContentOffsetX) / KSCREEN_WIDTH; //计算手指滑动了多少距离 CGFloat fingerDistance = secondScrollViewContentOffsetX - KSCREEN_WIDTH * buttonTag; //获取到下一个按钮，并改变其字体大小和颜色，逐渐放大（根据手指滑动的距离动态改变） UIButton *buttonNext = (UIButton *)[self.view viewWithTag:(buttonTag + 100 + 1)]; buttonNext.titleLabel.font = [UIFont systemFontOfSize:(14.0 + fingerDistance * 4 / (KSCREEN_WIDTH))]; [buttonNext setTitleColor:[UIColor colorWithRed:(0.4f + 3 * fingerDistance / (KSCREEN_WIDTH * 5)) green:0.3 blue:0.3 alpha:1.0] forState:UIControlStateNormal]; //同样方法获取到当前按钮，并改变其字体大小和颜色恢复回原来样式，逐渐缩小（根据手指滑动的距离动态改变） UIButton *buttonCurr = (UIButton *)[self.view viewWithTag:(buttonTag + 100)]; buttonCurr.titleLabel.font = [UIFont systemFontOfSize:(18.0 - fingerDistance * 4 / (KSCREEN_WIDTH))]; [buttonCurr setTitleColor:[UIColor colorWithRed:(1.0f - 3 * fingerDistance / (KSCREEN_WIDTH * 5)) green:0.3 blue:0.3 alpha:1.0] forState:UIControlStateNormal]; }  这里可以看到下一个按钮的字体动态改变，计算方法其实非常简单。 设手指滑动距离为x，字体大小为y。那么我们有两个值 (0,14), (KSCREEN_WIDTH, 18)。 然后列二元一次方程组，就可以得到 a 和 b。 我这里解得 a = 4/KSCREEN_WIDTD , b = 14\n当前按钮的改变亦然。只是两个点变为 (KSCREEN_WIDTH, 14), (0, 18) 计算得到 a = －(4/KSCREEN_WIDTH), b = 18\n颜色大家计算方式相似，不再赘述。\n3.使顶部scrollView随底部scrollView滑动而滚动 我们注意看网易新闻客户端，它底部scrollView滚动之后，顶部的scrollView也会随之滚动，并且除了开头或者末尾的几个按钮，它当前所在的新闻类型始终在屏幕中间。并且顶部的滚动总是在底部滑动结束之后，所以我们实现scrollView的代理方法\t- (void) scrollViewDidEndDecelerating:(UIScrollView *)scrollView \n//滑动结束调用的代理方法 - (void) scrollViewDidEndDecelerating:(UIScrollView *)scrollView { //**1.获取选中详情页对应的顶部button //移动顶部选中的按钮 CGFloat secondScrollViewContentOffsetX = scrollView.contentOffset.x; //获取选中按钮的序号 int buttonTag = (secondScrollViewContentOffsetX) / KSCREEN_WIDTH; //根据按钮号码获取到顶部的按钮 UIButton *buttonCurr = (UIButton *)[self.view viewWithTag:(buttonTag + 100)]; //**2.(重要)设置当前选中的按钮号。如若不写，将导致滑动后再点击顶部按钮，上一个按钮颜色，字体不会改变 self.currentButtonTag = buttonTag + 100; //**3.始终保持顶部选中按钮在中间位置 //注意一：开始的几个按钮，和末尾的几个按钮并不需要一直保持中间。 //注意二：对于已经放置在firstScrollView中的按钮，它的center是相对于scrollView的content而言的，注意并不是相对于self.view的bounds而言的。也就是说，放置好按钮，它的center就不会再改变 //如果是顶部scrollView即将到末尾的几个按钮，设置偏移量，直接return if (buttonCurr.center.x + KSCREEN_WIDTH * 0.5 \u003e self.firstScrollView.contentSize.width) { [UIView animateWithDuration:0.3 animations:^{ self.firstScrollView.contentOffset = CGPointMake(self.firstScrollView.contentSize.width - KSCREEN_WIDTH, 0); }]; return; } //如果是顶部scrollView开头的几个按钮，设置偏移量，直接return if (buttonCurr.center.x \u003c KSCREEN_WIDTH * 0.5) { [UIView animateWithDuration:0.3 animations:^{ self.firstScrollView.contentOffset = CGPointMake(0, 0); }]; return; } //如果是中间几个按钮的情况 if (buttonCurr.center.x \u003e (KSCREEN_WIDTH * 0.5)) { [UIView animateWithDuration:0.3 animations:^{ self.firstScrollView.contentOffset = CGPointMake(buttonCurr.center.x - self.view.center.x, 0); }]; } }  这里需要注意的是我注释里面的第2步和第3步。 第2步一定要写，否则导致先滑动底部scrollView，再点击顶部scrollView的button，出现之前的那个button样式不恢复的情况。 第3步，注意前几个按钮和后几个按钮位置的判断，如果一味保持按钮在中间，就会出现顶部的offset过多，而后面出现空白，大家可以简单尝试一下。\n整个效果就已经完成了～☺️\n","description":"","tags":["iOS"],"title":"纯代码高仿网易新闻客户端两个scrollView联动（二）：实现界面逻辑变换","uri":"/posts/twoscrollviewlinkage-2-businesslogic/"},{"categories":null,"content":"自己再开发app过程中遇到了这样那样的需求，其中有一项是新闻页面，需要两个scrollView联动，上面的scrollView是新闻类型，下面scrollView是tableView新闻标题。开发过程中我全部都是用代码布局的，因为自己是新手，不知道到底是用代码写比较方便还是用storyBoard更方便，但是感觉手写代码适应屏幕上更容易上手吧。需求实现之后现在拿出来简单整理一下，方便自己日后查看，也给后来者以参考。因为刚刚开始学，用到的都是些简单的方法，也可能会出错，如果有什么不足，请留言给我指出。谢谢～\n现在开始正题： 本文是第一篇，先是简单的页面布局，首先我们看一下布局之后的效果：\n1.宏定义 //屏幕的宽和高 #define KSCREEN_HEIGHT [UIScreen mainScreen].bounds.size.height #define KSCREEN_WIDTH [UIScreen mainScreen].bounds.size.width //最顶部状态栏的高度 #define KSTATUS_HEIGHT 20 //顶部items的scrollView的高度 #define KFIRST_SCROLLVIEW_HEIGHT 30 //根据计算，得到底部详情scrollView的高度 #define KSECOND_SCROLLVIEW_HEIGHT (KSCREEN_HEIGHT - KSTATUS_HEIGHT - KFIRST_SCROLLVIEW_HEIGHT) //顶部scrollView每个item按钮的宽度 #define KFIRST_SCROLLVIEW_ITEM_WIDTH 55  2.首先定义需要用到的变量 @interface ViewController () //顶部items的scrollView @property (nonatomic, weak) UIScrollView *firstScrollView; //底部详情scrollView @property (nonatomic, weak) UIScrollView *secondScrollView; //item类型的数组 @property (nonatomic, strong) NSArray *itemsTitlesArray; //为了方便，定义一个包含颜色的NSArray（自行取舍） @property (nonatomic, strong) NSArray *colorArray; @end  3.懒加载 #pragma mark - lazy load //定义items的标题 - (NSArray *) itemsTitlesArray { if (!_itemsTitlesArray) { _itemsTitlesArray = [NSArray arrayWithObjects:@\"热点新闻\", @\"新闻快讯\", @\"通知公告\", @\"院系通知\", @\"人物风采\", nil]; } return _itemsTitlesArray; } //颜色数组 - (NSArray *) colorArray { if (!_colorArray) { _colorArray = [NSArray arrayWithObjects: [UIColor colorWithRed:240.0/255.0 green:89.0/255.0 blue:136.0/255.0 alpha:1.0], [UIColor colorWithRed:0.0/255.0 green:179.0/255.0 blue:155.0/255.0 alpha:1.0], [UIColor colorWithRed:244.0/255.0 green:131.0/255.0 blue:69.0/255.0 alpha:1.0], [UIColor colorWithRed:241.0/255.0 green:90.0/255.0 blue:102.0/255.0 alpha:1.0], [UIColor colorWithRed:0.0/255.0 green:179.0/255.0 blue:155.0/255.0 alpha:1.0], [UIColor colorWithRed:255.0/255.0 green:223.0/255.0 blue:104.0/255.0 alpha:1.0], nil]; } return _colorArray; }  4.添加顶部items的scrollView //添加第一个scrollview - (void) addFirstScrollViewOnView { //**1.设置顶部类型scrollView UIScrollView *firstScrollView = [[UIScrollView alloc] initWithFrame:CGRectMake(0, KSTATUS_HEIGHT, KSCREEN_WIDTH, KFIRST_SCROLLVIEW_HEIGHT)]; firstScrollView.bounces = NO;//禁止反弹 firstScrollView.showsHorizontalScrollIndicator = NO;//禁止显示水平滚动条 //设置scrollView的内容大小，宽度为 宏定义顶部按钮的宽度 ＊ items数组的数量 firstScrollView.contentSize = CGSizeMake(self.itemsTitlesArray.count * KFIRST_SCROLLVIEW_ITEM_WIDTH, KFIRST_SCROLLVIEW_HEIGHT); self.firstScrollView = firstScrollView; [self.view addSubview:firstScrollView];//添加到self.view //**2.为第一个scrollView添加buttons for (int i = 0; i \u003c self.itemsTitlesArray.count; i ++) { UIButton *itemButton = [[UIButton alloc] initWithFrame:CGRectMake(i * KFIRST_SCROLLVIEW_ITEM_WIDTH, 0, KFIRST_SCROLLVIEW_ITEM_WIDTH, KFIRST_SCROLLVIEW_HEIGHT)];//注意左边距的写法 [itemButton setTitle:[self.itemsTitlesArray objectAtIndex:i] forState:UIControlStateNormal];//标题 itemButton.backgroundColor = [UIColor colorWithRed:0.97 green:0.97 blue:0.97 alpha:1.0];//背景颜色 [itemButton setTitleColor:[UIColor colorWithRed:0.4 green:0.4 blue:0.4 alpha:1.0] forState:UIControlStateNormal];//标题颜色 itemButton.titleLabel.font = [UIFont systemFontOfSize:14.0]; [firstScrollView addSubview:itemButton];//添加到第一个scrollView //定义第一个顶部item的按钮样式 if (i == 0) { itemButton.titleLabel.font = [UIFont systemFontOfSize:18.0f]; [itemButton setTitleColor:[UIColor colorWithRed:1.0 green:0.3 blue:0.3 alpha:1.0f] forState:UIControlStateNormal]; } } }  5.添加底部详情scrollView //添加第二个scrollview - (void) addSecondScrollViewOnView { //**1.设置底部详情scrollView UIScrollView *secondScrollView = [[UIScrollView alloc] initWithFrame:CGRectMake(0, KSTATUS_HEIGHT + KFIRST_SCROLLVIEW_HEIGHT, KSCREEN_WIDTH, KSECOND_SCROLLVIEW_HEIGHT)]; secondScrollView.pagingEnabled = YES;//分页 secondScrollView.bounces = NO;//禁止反弹 secondScrollView.delegate = self; //设置内容大小，宽度为 屏幕的宽度 * items数组的数量 secondScrollView.contentSize = CGSizeMake(self.itemsTitlesArray.count * KSCREEN_WIDTH, KSECOND_SCROLLVIEW_HEIGHT); self.secondScrollView = secondScrollView; [self.view addSubview:secondScrollView]; //**2.添加Views for (int i = 0; i \u003c self.itemsTitlesArray.count; i ++) { UIView *bottomView = [[UIView alloc] initWithFrame:CGRectMake(i * KSCREEN_WIDTH, 0, KSCREEN_WIDTH, KSECOND_SCROLLVIEW_HEIGHT)]; bottomView.backgroundColor = [self.colorArray objectAtIndex:(i % 6)];//颜色数组取余 //为了方便观察，放置一个label，如果需要其它控件自行替换（如若新闻，用tableView） UILabel *flagLabel = [[UILabel alloc] initWithFrame:bottomView.bounds]; flagLabel.font = [UIFont systemFontOfSize:50.0f]; flagLabel.textColor = [UIColor whiteColor]; flagLabel.textAlignment = NSTextAlignmentCenter; flagLabel.text = [NSString stringWithFormat:@\"%@\", [self.itemsTitlesArray objectAtIndex:i]]; [bottomView addSubview:flagLabel]; [secondScrollView addSubview:bottomView]; } }  6.在-(void)viewDidLoad方法中调用两个添加scrollView的方法 - (void)viewDidLoad { [super viewDidLoad]; [self addFirstScrollViewOnView];//添加顶部items的scrollView [self addSecondScrollViewOnView];//添加底部详情的scrollView }  7.声明 本文涉及的一切代码，都将上传到我的github仓库:https://github.com/Gitzhaoyang/iOSWithOC/tree/master/twoScrollViewLinkage，请自行查看。\n","description":"","tags":["iOS"],"title":"纯代码高仿网易新闻客户端两个scrollView联动（一）：设置基本的界面布局","uri":"/posts/twoscrollviewlinkage-1-baseview/"},{"categories":null,"content":"实现原理十分简单，使用UIImageView的透明度即可。然后在动画中完成。 alpha = 1 为全透明。 运行图例：\n实现代码:\n//图片渐隐渐现 self.backgroundView.alpha = 0.7; [UIView animateWithDuration:0.5 animations:^{ self.backgroundView.alpha = 1; self.backgroundView.image = [UIImage imageNamed:@\"weather_bg_02.jpg\"]; }];   后来我知道了可以用更好的方法实现， 后续会有更新\n","description":"","tags":["iOS"],"title":"UIImageView更换图片时渐隐渐现","uri":"/posts/uiimageview-image-fade-out/"},{"categories":null,"content":"一开始自己将tabBar全部自定义，将系统tabbar设置为self.tabBar.hidden=YES，隐藏系统的tabbar。但是自定义的tabbar在push出新页面的时候，tabbar并不会自动隐藏。之后在新页面viewWillAppear中设置自动隐藏，但是pop回之前页面（在viewDidAppear中设置tabbar显示）又出现不能及时出现，会有时间延迟，看上去特别不舒服。而且，边缘返回旧页面的时候不能及时显示tabbar也，所以打算用系统默认的tabbar。记录下系统tabBar样式的简单定义。\n简单自定义系统的tabBar - (void) initTabBarView { NSArray *titles = @[@\"工大威海\", @\"校园应用\", @\"校园生活\", @\"更多功能\"]; //tabBarItem选中图片简单颜色变化时，自定义选中后的颜色 [self.tabBar setTintColor:[UIColor redColor]]; int i = 0; for (UITabBarItem *item in self.tabBar.items) { //自定义tabBarItem的图片 item.image = [[UIImage imageNamed: [NSString stringWithFormat:@\"home_tab_icon_%d\", i + 1]] imageWithRenderingMode:UIImageRenderingModeAutomatic]; //定义选中图片,上面imageWithRederingMode设置为Automatic，只是简单颜色变换，不需要设置,不再赘述 //item.selectedImage = .... //设置tabBarItem的标题 item.title = titles[i]; i ++; } }  这是运行后的样式：\npush新页面tabBar自动隐藏，pop回显示tabBar 上面说如果用完全自定义的tabbar，我只能设置到等pop回的页面全部出现之后再让tabBar显示出来，这样十分不友好，我们如果实现手机微信类似这样的效果我们应该如何设置呢？注意红框部分\n我们应该在要push出新页面的那个页面设置viewDidAppear和viewWillDisappear方法：\n- (void) viewDidAppear:(BOOL)animated { [super viewWillAppear:animated]; [self setHidesBottomBarWhenPushed:YES]; } - (void) viewWillDisappear:(BOOL)animated { [self setHidesBottomBarWhenPushed:NO]; [super viewDidDisappear:animated]; }  边缘拖动返回的时候，即可实现如下效果：\n完成~ 😏😏😏\n","description":"","tags":["iOS"],"title":"UITabBarController嵌套UINavigationController后，关于tabBar的问题以及解决方法","uri":"/posts/how-to-use-sethidebottombarwhenpushed/"},{"categories":null,"content":"UIImageView三种contentMode区别：UIViewContentModeScaleToFill、UIViewContentModeScaleAspectFit、UIViewContentModeScaleAspectFill\n原图片： UIViewContentModeScaleToFill： UIViewContentModeScaleAspectFit UIViewContentModeScaleAspectFill ","description":"","tags":["iOS"],"title":"UIImageView 中图片的几种常用适应方式","uri":"/posts/some-uiimageview-fit-way/"},{"categories":null,"content":"今天在学习iOS开发的时候，偶然发现tableView有两种重用cell的方法。先整理一下方便日后查阅。\n第一种：[tableView dequeueReusableCellWithIdentifier:identifier] （SDK 6.0之前）\n第二种：[tableView dequeueReusableCellWithIdentifier:identifier forIndexPath:indexPath]] （SDK 6.0之后）\n区别： 第一种：必须判断cell是否定义，未定义则手动创建，代码如下：\nconst NSString *identifier = @\"cell\"; UITableView *cell = [tableView dequeueReusableCellWithIndetifier:identifier]; if(!cell) { cell = [[UITableView alloc] initWithStyle:UITableViewCellStyleDefault]; } /* 设置cell cell.textLable.text = @\"第...行\"; */ return cell;  第二种是SDK 6.0开始新添加的方法。用于你已经用Nib定义了一个Cell，然后就可以省下上面那些代码，只用一行就可以解决：\n UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@\"cell\" forIndexPath:indexPath]; /* 设置cell cell.textLable.text = @\"第...行\"; */  所以如果有这个错误：\nreason: 'unable to dequeue a cell with identifier friendCell - must register a nib or a class for the identifier or connect a prototype cell in a storyboard'  应该想一下自己是不是为cell创建的Nib。\n","description":"","tags":["iOS"],"title":"tableView 两种重用cell的方法区别","uri":"/posts/two-methods-to-reuse-cell/"},{"categories":null,"content":"Markdown 介绍  Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。Markdown的使用十分简单，常用的标记其实就十几个，所以相对于HTML这种复杂的标记语言来说，Markdown是十分轻量的标记语言。\n Markdown的基本使用   加粗和斜体 *斜体* _斜体_\n只要用一个_或者一个#包裹文字，即可实现文字斜体。\n**加粗文字** __加粗文字__\n只要用两个_或者两个#包裹文字，即可实现文字粗体。\n  链接与图片 插入链接和图片的格式很相似，只有一个!的区别\n链接格式为：[链接文字](链接地址)\n图片格式为：![图片名字](图片地址)\n在Markdown中插入图片地址要用到图床，我用到的是围脖图床修复计划和云图图床，上传图片就可以生成URL\n  标题 标题是文章中最常用的文本格式，在Markdown中只要在一行文字前添加#，即可标记为标题格式。\n＃ 一级标题\n## 二级标题\n### 三级标题\n以此类推，Markdown一共有六级标题，六级标题只需要加上六个######即可。\n  列表 列表有有序列表和无序列表\n有序列表格式：\n 1. 红色 2. 蓝色 3. 黑色  无序列表格式：\n * 红色 * 蓝色 * 黑色    引用 引用只需要在文字前面加上 \u003e 就可以了。你可以联合其它的标记符一起使用。\n \u003e * 引用中列表 \u003e * 列表 \u003e ### 引用中三级标题 \u003e\u003e 二级引用    行内代码和代码块 行内代码格式： ｀这里写代码｀\n代码块格式： 只要比上一行进行右缩进即可。按键盘tab键可以实现缩进\n  表格 表格应该是Markdown中最难的标记了\n最简单的表格：\n | First Header | Second Header | Third Header | | ------------ | ------------- | ------------ | | Content Cell | Content Cell | Content Cell | | Content Cell | Content Cell | Content Cell |  你也可以设置文字的对齐方式\n First Header | Second Header | Third Header :----------- | :-----------: | -----------: Left | Center | Right Left | Center | Right    水平分隔线 使用 --- 或者 ***即可。\n  删除线 删除线格式：\n ~~删除线~~    换行 只要在文字每行文字后面加上两个或两个以上的空格即可实现换行\n  注意  标记符号后面一定加上空格 标记语言必须使用英文符号 如果使用正确而不起作用，换一行再试一次  Markdown编辑工具 本人使用的工具是Mac OS下的Mou,支持实时预览，文章中的截图即为Mou的截图。你也可以在Github上搜索其它主题样式进行安装。\nMac下Markdown编辑器：Mou ¥0、Byword ¥40、iA Writer ¥128、Ulysses ¥283 etc.\nWindows下Markdown编辑器：MarkdownPad、MarkPad etc.\n官方文档 英文Markdown文档\n中文Markdown文档\n","description":"","tags":["Markdown","Hexo"],"title":"MarkDown基本使用方法","uri":"/posts/markdown-base-use/"},{"categories":null,"content":"罗列了UIscrollView的一些基本设置和常用方法\n  (void)viewDidLoad { [super viewDidLoad]; // [self initScrollView]; // [self initPageCtrl]; // [self addTimer]; self.scrollView = [[UIScrollView alloc]initWithFrame:CGRectMake(10, 20, 320, 460)]; self.scrollView.backgroundColor = [UIColor blueColor]; //是否支持滑动到最顶端 self.scrollView.scrollsToTop = NO; //设置UIScrollView的代理 self.scrollView.delegate = self; //设置内容大小 self.scrollView.contentSize = CGSizeMake(320 * 10, 460); //是否反弹 self.scrollView.bounces = NO; //是否滚动 self.scrollView.scrollEnabled = YES; //是否分页 self.scrollView.pagingEnabled = NO; //设置indecator风格 self.scrollView.indicatorStyle = UIScrollViewIndicatorStyleWhite; //设置内容边缘和Indicator边缘 self.scrollView.contentInset = UIEdgeInsetsMake(0, 50, 50, 0); self.scrollView.scrollIndicatorInsets = UIEdgeInsetsMake(0, 50, 0, 0); //是否同时运动 self.scrollView.directionalLockEnabled = NO;\n [self.view addSubview:self.scrollView];  }\n//是否支持滑动到顶部\n (BOOL) scrollViewShouldScrollToTop:(UIScrollView *)scrollView { return YES; }  //滑动到顶部时调用该方法\n (void) scrollViewDidScrollToTop:(UIScrollView *)scrollView { NSLog(@“滑动到顶部了”); }  //已经滑动(正在滑动也会调用该方法)\n (void) scrollViewDidScroll:(UIScrollView *)scrollView { NSLog(@“已经开始滑动”); }  //开始拖动\n (void) scrollViewWillBeginDragging:(UIScrollView *)scrollView { NSLog(@“开始拖动”); }  //结束拖动\n (void) scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate { NSLog(@“结束拖动”); }  //开始减速\n (void) scrollViewWillBeginDecelerating:(UIScrollView *)scrollView { NSLog(@“开始减速”); }  //减速停止\n (void) scrollViewDidEndDecelerating:(UIScrollView *)scrollView { NSLog(@“减速停止”); }  //结束滚动动画\n  (void) scrollViewDidEndScrollingAnimation:(UIScrollView *)scrollView { NSLog(@“结束滚动动画”); }\n  (void)didReceiveMemoryWarning { [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated. }\n   ","description":"","tags":["iOS"],"title":"UIScrollView的基本属性设置和常用代理方法","uri":"/posts/how-to-use-uiscrollviewdelegate/"},{"categories":null,"content":"-(BOOL)respondsToSelector: selector //用来判断是否有以某个名字命名的方法（被封装在一个selector的对象里传递）\n @protocol appViewDelegate \u003cNSObject\u003e @optional - (void) theButtonOnClicked:(UIButton *)button; @end   if([self.delegate respondsToSelector:@selector(theButtonOnClicked:)]) { self.delegate theButtonOnClicked:sender; }   #pragma mark - appViewDelegate - (void) theButtonOnClicked:(UIButton *)button { button.enabled = NO; []button setTitle:@\"已下载\" ForState:UIControlStateDisabled]; }  ","description":"","tags":["IOS"],"title":"函数respondsToSelector的使用","uri":"/posts/how-to-use-founction-respondstoselector/"},{"categories":null,"content":"这一篇是本系列的最后一篇，到目前为止，我们搭建的Hexo博客已经能满足我们日常的需求。可是有没有想过我们其实只能在这一台电脑上更新我们的博客？如果有一天我换了一台电脑，或者公司和家里不同的电脑都想更新博客，应该怎么办呢？\n这里只给类似我这样的git新人做参考，git的很多用法我也不太熟练。如果有错误还请各位指正。\n这里需要注意的是，当我们执行$ hexo deploy，部署到Github上面的是hexo给我们生成的静态页面，并不是整个hexo博客工程文件，所以并不能简单的在不同PC的更新博客。\n其实有两种办法，第一就是**_把整个目录备份到云盘_**，然后开启云盘同步该文件夹，虽然操作简单，但是同步很麻烦，需要手动将文件夹进行覆盖。第二种就是**_使用Git的第三方服务_**，只要配置完成，不管到哪里，用哪台电脑都能简单实现更新博客（当然需要Node.js和Git运行环境，在我们本系列的第一篇有讲解）。\n在本文中详细讲解如何使用第三方git服务进行博客的备份。可以Github放在共有仓库，如果你担心泄密，可以用Github的私有仓库（收费），国内除了Github还有许多知名的git服务商，如：gitcafe，bitbucket，oschina，coding等，据我了解，oschina的私有仓库是免费的，而且可以和Github进行同步。因为我们的博客放在了Github，所以我们不妨就把我们博客程序也同步到Github的仓库中。\n下面我们就来讲解如何实现不同电脑同时更新博客。\n将我们的博客目录备份到Github，实现多PC维护 在Github网站创建一个新的repository 我们在这里给新创建的repository命名为blog；\n不会创建方法的朋友可以参考在Github上面搭建Hexo博客（一）中的创建方法。\n在A电脑中从本地上传Hexo到Github仓库 A电脑指的是建立Hexo博客的电脑。\n  初始化仓库 在Hexo博客的根目录运行Git Bash并输入以下命令：\n $ git init $ git remote add origin \u003cserver address\u003e  这里\u003cserver\u003e指的是在线仓库的地址，比如在这里我的就应该是https://github.com/Gitzhaoyang/blog.git，如果你用其它git仓库服务，填写对应仓库地址即可。 origin是本地分支,remote add会将本地仓库映射到Github仓库\n  把本地文件同步到Github上面 分别输入执行以下命令：\n $ git add . #添加所有目录，注意add后面有个点`.` $ git commit -m \"add to Github\" #添加提交说明，每次提交都需要 $ git push -u origin master #把更新推送到云端  这时可以登录Github账户查看刚创建的blog仓库中是否上传成功\nwindows平台可能push过程中会提示输入Github的用户名和Github的密码，输入正确便是。\n  注意: 为了在另一台电脑上配置更加方便，严重建议把Hexo博客目录下_config.yml文件复制粘贴一份，并重命名为hexo_config.yml；把themes目录下你用到主题目录下的_config.yml文件也复制一份，并粘贴到博客根目录，注意，是’博客根目录'，并命名为theme_config.yml。原因是我们上传的时候，我们自己安装的themes如：[NexT](http://theme-next.iissnan.com)，它的'next'目录并不能上传，所以我们需要把这两个配置文件都保存下来在进行同步工作。\n在B电脑中从Github仓库取回Hexo到本地 B电脑指的是另一台电脑，如果没有另一台电脑也可以找地方新建一个文件夹尝试。\n  安装Git和Node.js 值得注意的是新电脑也需要安装Git和Node.js环境，参考本系列的第一篇中安装方法。\n  把文件取回本地 安装环境完成后，在新文件夹下运行Git Bash并分别执行以下几条命令：\n$ git init $ git remote add origin \u003cserver\u003e $ git fetch --all $ git reset --hard origin/master  这里\u003cserver\u003e仍然是你的Giuhub地址。fetch是将仓库中的内容取出来。reset则是不做任何合并（merge）处理，直接把取出的内容保存。\n运行完reset后你会发现文件夹中就会出现刚刚上传的内容。但是配置并没有完成，请继续往下看。\n  配置新的Hexo 如果是新PC，不要忘记我们本机并没有安装Hexo博客\n  首先，在刚才的目录下执行以下命令以在新机器中安装Hexo\n $ npm install hexo --save    初始化Hexo并安装相应依赖包\n $ hexo init $ npm intall    记得在第一篇中讲过，新安装的Hexo是没有hexo-deployer-git依赖包的，需要手动安装\n $ npm install hexo-deployer-git --save    如果你在A机器上设置了订阅（feed），那么你需要重新烧制feed，需要重新安装依赖包，没有设置feed的可以略过\n $ npm install hexo-generation-feed --save    安装主题，我在上文中提到新安装的主题并不能被上传，所以也需要重新手动安装(以NexT主题为例)\n $ git clone https://github.com/iissnan/hexo-theme-next themes/next  这里要注意的是：themes/next是主题保存目录。\n  我们之前备份的两个配置文件hexo_config.yml和theme_config.yml有用了,hexo_config.yml重命名为_config.yml覆盖根目录下的同名文件，而theme_config.yml也重命名为_config.yml覆盖主题目录下的config.yml文件。注意文件名前面的下划线'_'。\n  输入命令$ hexo generate和命令$ hexo server，然后在浏览器输入localhost:4000中进行预览。如果没有问题那么我们在B电脑上就配置成功了。\n    在B电脑上更新博客 现在在B电脑上也可以像在A电脑上一样更新博客了，同样是$ hexo new post \"my_new_post\" 编辑完文章，然后执行$ hexo generate和$ hexo deploy就可以成功发表了。 这里$ hexo deploy命令是将我们的博客文章发表到我们的Github上的Hexo博客，并不是前文新建的blog仓库，新建的blog仓库用来保存我们的Hexo程序。\n把B电脑上的Hexo从本地同步到Github仓库 当发表完文章，我们还需要把Hexo程序同步到我们Github的blog仓库。执行下面指令：\n$ git add .  这是可以输入命令$ git status查看状态，回显示刚才编辑过的文件的信息。\n之后分别输入下面指令完成上传：\n$ git commit -m \"commit from PC_B\" $ git push -u origin master  成功后，我们再次把程序同步更新到了我们的Github仓库blog。 如果再想用A电脑更新我们的博客，只需要在执行添加文章之前先把程序从blog仓库拉取下来便可。输入命令：\n $ git pull https://github.com/Gitzhaoyang/blog.git  即可完成。\n注意: 我们每次更新博客时，为了保持我们每次用到的程序都是最新的。\n每次更新博客之前都需要执行$ git pull https://github.com/xxxx/xxx.git保持本地最新；\n每次更新博客之后都需要执行$ git add . ,$ git commit -m \"message\",$ git push -u origin master以保持Github仓库程序最新。\n好了，现在我们就能实现在不同电脑都能对我们的Hexo博客进行维护了。😎😘\n","description":"","tags":["Hexo","Github"],"title":"在Github上面搭建Hexo博客（四）:使用不同电脑维护","uri":"/posts/create-hexo-on-github-4/"},{"categories":null,"content":"更换主题很简单，首先感谢@iissnan，因为博主用的是@iissnan的NexT主题，所以本文就以NexT主题为例讲解如何更换博客主题。在文末我会给出更多优秀主题的Github地址。\n为自己的Hexo博客更换主题 我这里讲到的也是参考了NexT主题作者的使用文档，更详细的设置读者们可以直接去参考该使用文档。\n  下载NexT主题包 仍然在博客根目录下运行Git bash命令行工具，输入下面一条指令用以克隆最新版本：\n $ git clone https://github.com/iissnan/hexo-theme-next theme/next    启用主题 下载完成后，打开博客配置文件_config.theme，修改里面的theme字段，将其值设置为next\n  验证主题是否启用成功 在Git Bash中输入$ npm server启用本地服务，然后在浏览器中输入localhost:4000进行预览即可\n  更多详细的设置，不再赘述，可以参考NexT的使用文档 其他优秀的主题推荐：  iissnan/hexo-theme-next TryGhost/Casper daleanthony/uno orderedlist/modernist litten/hexo-theme-yilia A-limon/pacman AlxMedia/hueman kathyqian/crisp-ghost-theme  更多优秀的主题可以参考知乎回答：有哪些好看的hexo主题?－家顺张的回答\n","description":"","tags":["Hexo","Github"],"title":"在Github上面搭建Hexo博客（三）：更换Hexo主题","uri":"/posts/create-hexo-on-github-3/"},{"categories":null,"content":"如何配置Hexo 上一节中我们已经在本地和Github上搭建起了自己的博客，但是博客的配置都是默认值，如果我们想个性化自己的博客，我们应该做什么呢。这一节中我们一起来配置自己的博客的基本信息和介绍如何写博客和发表博客。下一节我们将一起为自己的博客安装新的主题。\n博客的主要配置用到根目录下的_config.yml文件，我在下面给出文件和解释，你只需要根据自己需求作出简单更改即可：\n# Hexo Configuration ## Docs: http://hexo.io/docs/configuration.html ## Source: https://github.com/hexojs/hexo/ # Site title: Mungo's Note\t##站点的名字 subtitle:\t##站点的副标题 description: 日常技术分享 ##站点介绍，对站点进行描述 author: Mungo\t##站点文章的作者 email: gmzhaoyang@gmail.com\t##你的邮箱地址 language:\t##语言，默认中文，不填写即可 timezone:\t##时区，默认即可 # URL ## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/' url: http://mungo.space\t##站点的域名，如果奇怪我为什么可以用自己的域名，可以看后续更新 root: /\tpermalink: :year/:month/:day/:title/ permalink_defaults: ## 对资源文件夹的配置，如资源文件夹名称，标签云名称，分类页面名称 # Directory source_dir: source\t##资源文件夹,当执行`$ hexo deloy`命令，上传的即是该文件夹里面的内容 public_dir: public\t##公共文件夹，当执行`$ hexo generate`命令，生成的文件都在里面 tag_dir: tags\t##标签云文件夹，需要自己生成，详情见下一节如何配置主题 archive_dir: archives\t##归档文件夹，需要自己生成 category_dir: categories\t##分类文件夹，需要自己生成 code_dir: downloads/code\t##代码存放区 i18n_dir: :lang skip_render: ##此处时配置博客文章内容格式的，可以保持默认，不做修改 # Writing new_post_name: :title.md # File name of new posts default_layout: post titlecase: false # Transform title into titlecase external_link: true # Open external links in new tab filename_case: 0 render_drafts: false post_asset_folder: false relative_link: false future: true highlight: enable: true line_number: true auto_detect: true tab_replace: #分类和标签云的配置，可以不做修改，默认即可 # Category \u0026 Tag default_category: uncategorized category_map: tag_map: #日期和时间格式的配置，可以不做修改，默认即可 # Date / Time format ## Hexo uses Moment.js to parse and display date ## You can customize the date format as defined in ## http://momentjs.com/docs/#/displaying/format/ date_format: YYYY-MM-DD time_format: HH:mm:ss #用来配置每页显示的文章数目，可以根据自己需求自行修改 # Pagination ## Set per_page to 0 to disable pagination per_page: 10 pagination_dir: page #插件和主题配置，在这里可以修改自己的主题 # Extensions ## Plugins: http://hexo.io/plugins/ ## Themes: http://hexo.io/themes/ theme: next #上传配置，上一节中我们已经配置完成了，在这里不需要再次修改 # Deployment ## Docs: http://hexo.io/docs/deployment.html deploy: type: git repository: https://github.com/Gitzhaoyang/gitzhaoyang.github.io.git branch: master  当配置完成并保存后，就可以执行$ hexo generate生成静态文件，然后执行$ hexo server后就可以打开浏览器输入localhost:4000进行本地预览了\ntips： 如果_config.yml文件打开有乱码应该是用到的编辑器的原因，我用的是Sublime2，所以一般不会出现乱码。如果乱码，那么需要把文件格式转换为UTF-8，转化方法我在这里就不再赘述了。\n如何添加和发表文章   新建文章 在Git Bash中输入\n $ hexo new post \"my_first_post\"    编辑文章 第一步的命令会在\\Hexo\\source\\_posts文件夹下创建一个后缀.md文件，你可以在里面添加任何字符串。\n这其实是一个markdown类型的文件，使用markdown语言编写，我这篇博文就是用markdown编写的，如果不了解的，可以看我的后续更新，我会把markdown的基本使用方法进行整理。\n  生成和上传   在GitBash中输入$ hexo generate对文件进行生成；\n  生成完成后，可以输入$ hexo server，然后在浏览器输入localhost:4000进行预览；\n  预览没有问题后，接着输入$ hexo deploy，windows平台下会提示输入Github的用户名，然后提示输入Github的登录密码。如果输入正确，等待几秒便能上传成功；\n  现在可以在浏览器中输入xxxx.github.io进行访问了。\n    注意:   可能不会立即生效，只要等待几分钟或者清空一下浏览器缓存基本就能解决。如果仍然看不到，说明前面步骤操作有错误，重新生成和上传就可以了。\n如果实在不行，可以在Git Bash中输入$ hexo clean或者手动删除.deploy_git文件夹和db.json文件再重新生成和上传。\n到目前为止，我们已经搭建起自己的博客，可以进行基本的配置，也可以发表文章，后面会有更高阶的设置，如：如何配置主题，如何在不同电脑上都可以更新自己的博客 etc.感兴趣的人可以关注。😘\n","description":"","tags":["Hexo","Github"],"title":"在Github上面搭建Hexo博客（二）：配置和发表文章","uri":"/posts/create-hexo-on-github-2/"},{"categories":null,"content":"什么是SSH SSH为Secure Shell的缩写，是建立在应用层和传输层基础上的协议。SSH是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用SSH协议可以有效防止远程管理中额信息泄漏问题。我理解的就是给数据进行加密，然后防止中间人进行盗取，能使你的数据安全可靠的传输到目的方。在这里就是为了保证你电脑和Github仓库之间通信的安全。\n如何配置Github的SSH 题主这里用的依然是windows平台。\nStep 1: 检查SSH keys 首先，我们要查看在你电脑上已经存在的SSH keys。运行Git Bash 然后输入：\n$ ls -al ~/.ssh  如果你已经有SSH公钥了。那么你将会看到下面格式的文件名字：\nid_dsa.pub id_esdsa.pub id_ed25519.pub id_rsa.pub  如果你已经存在公钥了，那么可以跳过Step 2直接去Step 3了。如果没有也不要担心，我们将在Step 2 会创建公钥。\nStep 2: 生成SSH key   在Git Bash中输入下面命令，引号内一定是你的Github注册邮箱地址  $ ssh-keygen -t rsa -b 4096 -C \"your_github_email@example.com\" #这句作用是生成一个新的SSH key    等待几秒，当提示让你输入保存地址时，官方特别推荐放在默认位置就可以了。所以这里直接输入回车，提示如下：  Enter file in which to save the key (/Users/you/.ssh/id_rsa):[直接输入回车]    将会提示你输入一个密码串**(这里输入密码时不会显示在屏幕上的，只要输入正确按回车就好)**:  Enter passphrase （empty for no passphrase）: [输入你想设置的密码] Enter same passphrase again：[在输入一遍密码] ＃虽然说这里可以设置为空，但是推荐用一个更加安全的密码    输完密码之后，你将会得到你的SSH的指纹(fingerprint)或者id。他看起来如下图：   Step 3: 把你的SSH key添加到ssh-agent   输入如下命令  $ ssh-agent -s  会响应：\n echo Agent pid [端口号]    加下来输入如下命令，把你的SSH key添加到ssh-agent  $ ssh-add ~/.ssh/id_rsa  如果他提示如下，说明不能打开您身份验证的代理\n Could not open a connection to your authentication agent.  只需要输入如下命令即可解决：\n ssh-agnet bash  更多关于ssh-agent的细节，可以用man ssh-agent 来查看\n  Step 4: 把你的SSH key添加到你的Github账户 首先你应该把你的 SSH key 复制到你的剪贴板，输入命令即可完成把 SSH key 复制到你的剪贴板：\n$ clip \u003c ~/.ssh/id_ras.pub  添加到你的Github账户：\n  浏览器登陆你的Github账户，点击右上角你的头像，然后点击Settings   进入Settings，点击侧栏选项SSH key   单击右边 Add SSH key 按钮   在下面输入标题（Title，这个可以自定义）和SHH Key（直接 Ctrl＋V 粘贴就可以）   点击下面的Add key按钮便可以添加成功了   Step 5: 测试是否连接成功   在Git Bash中输入：  $ ssh -T git@github.com # ssh尝试连接到GitHub    你可能看到下面的警告：  The authenticity of host 'github.com(207.97.227.239)' can't be established. RSA key fingerprint is SHA256:nJKJFKDnDLFJDndndnfkdfldjfldldfjld. Are you sure you want to continue connecting (yes/no)?  确定提示信息里的指纹（fingerprint）是否匹配，如果匹配就键入｀yes｀，将得到：\n Hi [你的用户名]! You've successfully authenticated, but GitHub does not provide shell access.    如果提示信息中你的用户名是你的，那么你就成功建立了SSH key！😎😎   TIPS：如果遇到其他问题，可以参考官方文档，也可以给我留言 ","description":"","tags":["Github","SSH"],"title":"如何配置Github的SSH key","uri":"/posts/how-to-config-ssh-on-github/"},{"categories":null,"content":"什么是Hexo Hexo是一个基于Node.js的静态博客程序，可以方便的生成静态网页托管在Github和Heroku上。并且有很多人为其制作了很多优秀的主题（theme），你可以根据自己的喜好进行设置。主题的设置将在后面的章节中介绍。\n这个是Hexo官方网站介绍：\n Hexo is a fast, simple and powerful blog framework. You write posts in Markdown (or other languages) and Hexo generates static files with a beautiful theme in seconds.\n 翻译过来就是：\n Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。\n 怎么在Github上搭建一个hexo博客 我用了一天时间研究和搭建了一个Github博客(GitHub Pages site)，过程中遇到一些小问题，现在写一篇教程，方便和我一样爱折腾但是是新手的人。\n注意： 因为题主在搭建时在Windows平台，所以讲解为Windows版本，但是各个平台大同小异，所以实践起来并没有很大的差别。\n以下为教程正文：\n安装Git 前往Git官网下载Windows版本压缩包，下载完成后解压安装。\n安装Node.js 前往Node.js官方下载网站，下载Node.js官方安装包，下载完成后同样解压安装。\n安装Hexo 到目前为止，安装Hexo所需要的环境已将安装完成，下一步只需要安装Hexo便可以了。 点击鼠标右键，看是否有Git bash Here选项。如果没有可以前往Git安装根目录，启动git-base.exe也可以。 在命令行中输入：\n$ npm install -g hexo-cli  Hexo 便安装完成了\n创建Hexo文件夹 找到想要放置博客的文件夹，比如（F:\\Hexo），在该目录下鼠标右击打开Gitbash工具，（右键菜单中没有该选项的可以用cmd命令cd等进入该文件夹）。执行下面的语句，会在F:\\Hexo文件夹下创建node_modules文件夹：\n$ hexo init  这里init后面可以跟文件目录，比如我想在F:\\Hexo下创建博客文件夹，那么可以用下面的命令：\n$ hexo init F:\\Hexo  安装依赖包 在Hexo目录下，执行以下命令，你会发现F:\\Hexo\\node_modules目录下多了好多文件夹\n$ npm install  本地调试 目前为止，已经搭建好自己的Hexo博客了，但是只能在本机上查看。执行以下两个命令（在F:\\Hexo目录下），然后在浏览器中输入 localhost:4000 就可以看到自己的博客了\n$ hexo generate $ hexo serrver  但是只能在本地查看，如果想让别人也能访问，那么就需要部署到Github 上面，下面，我们就部署上去。\n注册Github账户 前往Github网站，注册一个新用户。用邮箱注册的一定前往邮箱去验证邮件。要不然之后可能会有小问题。\n创建一个新的repository 在自己的Github主页右下角,创建一个新的repository。比如我的Github用户名为Gitzhaoyang，那么我创建的repository的名字应该是 gitzhaoyang.github.io 。\n这里严重注意: 一定要以你的Github用户名.github.io创建。假如我没有用gitzhaoyang.github.io而是用了mungo.github.io，那么当我浏览器访问博客的时候会出现404错误。这里并不是没有部署成功，而是把它部署在了这里:http://gitzhaoyang.github.io/mungo.github.io。所以，如果想直接gitzhaoyang.github.io访问，那么就需要和用户名保持一致。题主在这里吃了不小的苦头，最后给Github客服发邮件才知道原因。\n创建好如下图：\n将本地的文件部署（上传）到Github账户中 编辑本地Hexo目录下文件_comfig.yml，在最后添加如下代码（在你修改时，把 gitzhaoyang 要替换成你自己的用户名）\ndeploy: type: git repository: http://github.com/Gitzhaoyang/gitzhaoyang.github.io.git branch: master  .yml文件对格式规范要求很严格，type: repository: branch: 前面有两个空格，冒号后面都有一个空格。\n执行以下指令即可完成部署（如果提示错误，可以看下面注意）：\n$ hexo generate $ hexo deploy  注意：   有些用户没有设置Github的SSH，会导致上面两句失败。SSH的介绍和设置方法可以查看官方教程,配置起来很简单。如果英文看不明白或者过程中出现小问题，可以查看我写的SSH设置教程，是对官方教程的解释和扩展，针对配置过程中的小问题都有解决办法。\n  每次修改本地文件，都需要命令$ hexo generate才能保存。而且每次使用命令都必须在Hexo根目录下使用。\n  如果你在执行$ hexo deloy,如果提示 ERROR Deployer not found: git，那说明你没有安装hexo-deployer-git依赖包，进入F:\\Hexo\\node_modules发现真的没有hexo-deployer-git，不用担心，只需要输入下面命令创建hexo-deployer-git依赖包，然后再执行hexo deploy就能上传成功了\n $ npm install hexo-deployer-git --save    如果你是windows用户，那么当你执行$ hexo deploy命令的时候，可能会先后出现提示框让你输入你的Github用户名和Github密码，只要输入正确，上传就没有问题。\n  好了，现在我们的博客已经在Github上面部署成功了，可以在浏览器访问gitzhaoyang.github.io试试了。\n提示： 现在Hexo支持更加简单的命令格式了，比如：\nhexo s == hexo server hexo g == hexo generate hexo d == hexo deploy hexo n == hexo new  后续我会把如何配置博客信息，发表文章，设置博客主题，不同电脑间进行同时更新自己的Blog的方法等更新上来,感兴趣的人可以关注\n","description":"","tags":["Hexo","Github"],"title":"在Github上面搭建Hexo博客（一）：部署到Github","uri":"/posts/create-hexo-on-github-1/"},{"categories":null,"content":"深入剖析 Golang Pprof 标签 Polar Signal 提供的持续分析工具可以和任何格式的 pprof 配置适配，Go 深度集成了 pprof 甚至支持了它的标签特性。然而，自从我们发布了我们持续分析的产品之后，我们收到了很多工程师的反馈，发现许多工程师不知道如何去分析，或者不知道分析能给他们带来什么好处。这篇文章主要剖析 pprof 标签，并会结合一些 Go 的示例代码去分析。\n基础 pprof 标签只支持 Go 的 CPU 分析器。Go 的分析器是抽样分析，这意味着它只会根据特定的频率（默认是 1 秒钟 100 次）去获取执行中函数的调用栈并记录。简单来说，开发者如果使用标签，在分析器取样时就可以将函数的调用栈进行区分，然后只聚合有相同标签的函数调用栈。\nGo 在 runtime/pprof 包中已经支持了标签检测，可以使用 pprof.Do 函数非常方便的使用。\n1 2 3  pprof.Do(ctx, pprof.Labels(\"label-key\", \"label-value\"), func(ctx context.Context) { // execute labeled code })   进阶 为了进行演示如何使用 pprof 标签，我们创建了一个包含许多示例的仓库，示例仓库会作为这篇文章内容的说明。仓库地址：https://github.com/polarsignals/pprof-labels-example\n示例代码的 main.go 通过将 tanant 传递给 iterate 函数实现了大量的 for 循环，其中tanant1 做了 10 亿次循环，而 tanant2 做了 1 亿次循环，同时会记录 CPU 的分析日志并将其写入 ./cpuprofile.pb.gz。\n为了演示如何在 pprof 的分析日志中展示 pprof 标签，用 printprofile.go 来打印每次抽样函数调用栈以及样本值，还有收集到样本的标签。\n如果我们注释掉 pprof.Do 的这部分，我们将无法进行标签检测，运行 printprofile.go 代码，让我们看看没有标签的抽样分析日志：\n1 2 3 4 5 6 7 8 9 10 11 12 13  runtime.main main.main main.iteratePerTenant main.iterate 2540000000 --- runtime.main main.main main.iteratePerTenant main.iterate 250000000 --- Total: 2.79s   CPU 分析数据的单位是 纳秒，所以这些抽样总共花费时间是 2.79 秒（2540000000ns + 250000000ns = 2790000000ns = 2.79s）。\n同样的，现在当每次调用 iterate 时添加标签，用 pprof 分析，这些数据看起来就不太一样，打印出带有标签的抽样分析日志：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  runtime.main main.main main.iteratePerTenant runtime/pprof.Do main.iteratePerTenant.func1 main.iterate 10000000 --- runtime.main main.main main.iteratePerTenant runtime/pprof.Do main.iteratePerTenant.func1 main.iterate 2540000000 map[tenant:[tenant1]] --- runtime.main main.main main.iteratePerTenant runtime/pprof.Do main.iteratePerTenant.func1 main.iterate 10000000 map[tenant:[tenant1]] --- runtime.main main.main main.iteratePerTenant runtime/pprof.Do main.iteratePerTenant.func1 main.iterate 260000000 map[tenant:[tenant2]] --- Total: 2.82s   将所有抽样加起来总共花费了 2.82 秒，然而，因为调用 iterate 时，我们添加了标签，所以我们能在结果中区分哪个 tanant 导致了更多的 CPU 占用。现在我们可以说 tenant1 花费了总时间 2.82 秒中的 2.55 秒（2540000000ns + 10000000ns = 2550000000ns = 2.55s）。\n让我们看看抽样的原始日志（还有它们的元数据），去更深入理解一下它们的格式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  $ protoc --decode perftools.profiles.Profile --proto_path ~/src/github.com/google/pprof/proto profile.proto \u003c cpuprofile.pb | grep -A12 \"sample {\" sample { location_id: 1 location_id: 2 location_id: 3 location_id: 4 location_id: 5 value: 1 value: 10000000 } sample { location_id: 1 location_id: 2 location_id: 3 location_id: 4 location_id: 5 value: 254 value: 2540000000 label { key: 14 str: 15 } } sample { location_id: 6 location_id: 2 location_id: 3 location_id: 4 location_id: 5 value: 1 value: 10000000 label { key: 14 str: 15 } } sample { location_id: 1 location_id: 2 location_id: 3 location_id: 7 location_id: 5 value: 26 value: 260000000 label { key: 14 str: 16 } }   我们可以看到每个抽样都由许多 ID 组成，这些 ID 指向它们在分析日志 location 数组中的位置，除了这些 ID 还有几个值。仔细看下 printprofile.go 程序，你会发现它使用了每个抽样的最后一个抽样 value。 实际上，Go 的 CPU 分析器会记录两个 value，第一个代表这个调用栈在一次分析区间被记录样本的数量，第二个代表它花费了多少纳秒。pprof 的定义描述当没设置 default_sample_type 时（在 Go 的 CPU 配置中设置），就使用所有 value 中的最后一个，因此我们使用的是代表纳秒的 value 而不是样本数的 value。最后，我们可以打印出标签，它是 pprof 定义的一个以字符串组成的字典。\n最后，因为用标签去区分数据，我们可以让可视化界面更直观。\n你可以在 Polar Signals 网站这里去更详细的了解上面的这次分析：https://share.polarsignals.com/2063c5c/\n结论 pprof 标签是帮助我们理解不同执行路径非常有用的方法，许多人喜欢在多租户系统中使用它们，目的就是为了能够定位在他们系统中出现的由某一个租户导致的性能问题。就像开头说的，只需要调用 pprof.Do 就可以了。\nPolar Signals 提供的持续分析工具也支持了 pprof 标签的可视化界面和报告，如果你想参与个人体验版请点击：申请资格\n via: https://www.polarsignals.com/blog/posts/2021/04/13/demystifying-pprof-labels-with-go/\n作者：Frederic Branczyk 译者：h1z3y3 校对：校对者ID\n本文由 GCTT 原创编译，Go 中文网 荣誉推出\n","description":"","tags":null,"title":"东隅已逝/桑榆非晚","uri":"/posts/demysitifying-pprof-labels-with-go/"}]